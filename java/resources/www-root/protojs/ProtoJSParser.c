/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : ProtoJS.g
 *     -                            On : 2012-11-06 01:39:24
 *     -                for the parser : ProtoJSParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "ProtoJSParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pProtoJSParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pProtoJSParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pProtoJSParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pProtoJSParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a ProtoJSParser_message scope set 
 */
static pProtoJSParser_message_SCOPE   pProtoJSParser_messagePush(pProtoJSParser ctx);
static void ANTLR3_CDECL messageFree(pProtoJSParser_message_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL messageFree(pProtoJSParser_message_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser message scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_messageTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_message_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_message_SCOPE
pProtoJSParser_messagePush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_message_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_messageStack->size(ctx->pProtoJSParser_messageStack) > ctx->pProtoJSParser_messageStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_message_SCOPE)ctx->pProtoJSParser_messageStack->get(ctx->pProtoJSParser_messageStack, ctx->pProtoJSParser_messageStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_message_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_message_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_messageStack->push(ctx->pProtoJSParser_messageStack, newAttributes, (void (*)(void *))messageFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_messageStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a ProtoJSParser_enum_def scope set 
 */
static pProtoJSParser_enum_def_SCOPE   pProtoJSParser_enum_defPush(pProtoJSParser ctx);
static void ANTLR3_CDECL enum_defFree(pProtoJSParser_enum_def_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL enum_defFree(pProtoJSParser_enum_def_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser enum_def scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_enum_defTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_enum_def_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_enum_def_SCOPE
pProtoJSParser_enum_defPush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_enum_def_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_enum_defStack->size(ctx->pProtoJSParser_enum_defStack) > ctx->pProtoJSParser_enum_defStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_enum_def_SCOPE)ctx->pProtoJSParser_enum_defStack->get(ctx->pProtoJSParser_enum_defStack, ctx->pProtoJSParser_enum_defStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_enum_def_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_enum_def_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_enum_defStack->push(ctx->pProtoJSParser_enum_defStack, newAttributes, (void (*)(void *))enum_defFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_enum_defStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a ProtoJSParser_flags_def scope set 
 */
static pProtoJSParser_flags_def_SCOPE   pProtoJSParser_flags_defPush(pProtoJSParser ctx);
static void ANTLR3_CDECL flags_defFree(pProtoJSParser_flags_def_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL flags_defFree(pProtoJSParser_flags_def_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser flags_def scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_flags_defTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_flags_def_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_flags_def_SCOPE
pProtoJSParser_flags_defPush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_flags_def_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_flags_defStack->size(ctx->pProtoJSParser_flags_defStack) > ctx->pProtoJSParser_flags_defStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_flags_def_SCOPE)ctx->pProtoJSParser_flags_defStack->get(ctx->pProtoJSParser_flags_defStack, ctx->pProtoJSParser_flags_defStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_flags_def_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_flags_def_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_flags_defStack->push(ctx->pProtoJSParser_flags_defStack, newAttributes, (void (*)(void *))flags_defFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_flags_defStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a ProtoJSParser_field scope set 
 */
static pProtoJSParser_field_SCOPE   pProtoJSParser_fieldPush(pProtoJSParser ctx);
static void ANTLR3_CDECL fieldFree(pProtoJSParser_field_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL fieldFree(pProtoJSParser_field_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser field scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_fieldTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_field_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_field_SCOPE
pProtoJSParser_fieldPush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_field_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_fieldStack->size(ctx->pProtoJSParser_fieldStack) > ctx->pProtoJSParser_fieldStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_field_SCOPE)ctx->pProtoJSParser_fieldStack->get(ctx->pProtoJSParser_fieldStack, ctx->pProtoJSParser_fieldStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_field_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_field_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_fieldStack->push(ctx->pProtoJSParser_fieldStack, newAttributes, (void (*)(void *))fieldFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_fieldStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a ProtoJSParser_option_pair scope set 
 */
static pProtoJSParser_option_pair_SCOPE   pProtoJSParser_option_pairPush(pProtoJSParser ctx);
static void ANTLR3_CDECL option_pairFree(pProtoJSParser_option_pair_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL option_pairFree(pProtoJSParser_option_pair_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser option_pair scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_option_pairTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_option_pair_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_option_pair_SCOPE
pProtoJSParser_option_pairPush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_option_pair_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_option_pairStack->size(ctx->pProtoJSParser_option_pairStack) > ctx->pProtoJSParser_option_pairStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_option_pair_SCOPE)ctx->pProtoJSParser_option_pairStack->get(ctx->pProtoJSParser_option_pairStack, ctx->pProtoJSParser_option_pairStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_option_pair_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_option_pair_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_option_pairStack->push(ctx->pProtoJSParser_option_pairStack, newAttributes, (void (*)(void *))option_pairFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_option_pairStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}



/* globalAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declaration for creating a ProtoJSParser_Symbols scope set 
 */
static pProtoJSParser_Symbols_SCOPE   pProtoJSParser_SymbolsPush(pProtoJSParser ctx);
static void ANTLR3_CDECL SymbolsFree(pProtoJSParser_Symbols_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* globalAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL SymbolsFree(pProtoJSParser_Symbols_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser Symbols scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_SymbolsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_Symbols_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_Symbols_SCOPE
pProtoJSParser_SymbolsPush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_Symbols_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_SymbolsStack->size(ctx->pProtoJSParser_SymbolsStack) > ctx->pProtoJSParser_SymbolsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_Symbols_SCOPE)ctx->pProtoJSParser_SymbolsStack->get(ctx->pProtoJSParser_SymbolsStack, ctx->pProtoJSParser_SymbolsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_Symbols_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_Symbols_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_SymbolsStack->push(ctx->pProtoJSParser_SymbolsStack, newAttributes, (void (*)(void *))SymbolsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_SymbolsStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* globalAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declaration for creating a ProtoJSParser_NameSpace scope set 
 */
static pProtoJSParser_NameSpace_SCOPE   pProtoJSParser_NameSpacePush(pProtoJSParser ctx);
static void ANTLR3_CDECL NameSpaceFree(pProtoJSParser_NameSpace_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* globalAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL NameSpaceFree(pProtoJSParser_NameSpace_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a ProtoJSParser NameSpace scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pProtoJSParser_NameSpaceTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pProtoJSParser_NameSpace_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pProtoJSParser_NameSpace_SCOPE
pProtoJSParser_NameSpacePush(pProtoJSParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pProtoJSParser_NameSpace_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pProtoJSParser_NameSpaceStack->size(ctx->pProtoJSParser_NameSpaceStack) > ctx->pProtoJSParser_NameSpaceStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pProtoJSParser_NameSpace_SCOPE)ctx->pProtoJSParser_NameSpaceStack->get(ctx->pProtoJSParser_NameSpaceStack, ctx->pProtoJSParser_NameSpaceStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pProtoJSParser_NameSpace_SCOPE) ANTLR3_MALLOC(sizeof(ProtoJSParser_NameSpace_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pProtoJSParser_NameSpaceStack->push(ctx->pProtoJSParser_NameSpaceStack, newAttributes, (void (*)(void *))NameSpaceFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pProtoJSParser_NameSpaceStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   ProtoJSParserTokenNames[93+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "PROTO",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "PACKAGELITERAL",
        (pANTLR3_UINT8) "ITEM_TERMINATOR",
        (pANTLR3_UINT8) "QUALIFIEDIDENTIFIER",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IMPORTLITERAL",
        (pANTLR3_UINT8) "SERVICE",
        (pANTLR3_UINT8) "BLOCK_OPEN",
        (pANTLR3_UINT8) "BLOCK_CLOSE",
        (pANTLR3_UINT8) "RPC",
        (pANTLR3_UINT8) "PAREN_OPEN",
        (pANTLR3_UINT8) "PAREN_CLOSE",
        (pANTLR3_UINT8) "RETURNS",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "MESSAGE",
        (pANTLR3_UINT8) "EXTEND",
        (pANTLR3_UINT8) "EXTENSIONS",
        (pANTLR3_UINT8) "TO",
        (pANTLR3_UINT8) "RESERVE",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "EQUALS",
        (pANTLR3_UINT8) "ProtoJSOPTIONAL",
        (pANTLR3_UINT8) "REQUIRED",
        (pANTLR3_UINT8) "REPEATED",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "SQBRACKET_OPEN",
        (pANTLR3_UINT8) "SQBRACKET_CLOSE",
        (pANTLR3_UINT8) "OPTION_LITERAL",
        (pANTLR3_UINT8) "DEFAULT",
        (pANTLR3_UINT8) "FLOAT",
        (pANTLR3_UINT8) "DOUBLE",
        (pANTLR3_UINT8) "UINT32",
        (pANTLR3_UINT8) "INT32",
        (pANTLR3_UINT8) "SINT32",
        (pANTLR3_UINT8) "FIXED32",
        (pANTLR3_UINT8) "SFIXED32",
        (pANTLR3_UINT8) "UINT64",
        (pANTLR3_UINT8) "INT64",
        (pANTLR3_UINT8) "SINT64",
        (pANTLR3_UINT8) "FIXED64",
        (pANTLR3_UINT8) "SFIXED64",
        (pANTLR3_UINT8) "BOOL",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "BYTES",
        (pANTLR3_UINT8) "NORMAL",
        (pANTLR3_UINT8) "VECTOR2F",
        (pANTLR3_UINT8) "VECTOR2D",
        (pANTLR3_UINT8) "VECTOR3F",
        (pANTLR3_UINT8) "VECTOR3D",
        (pANTLR3_UINT8) "VECTOR4F",
        (pANTLR3_UINT8) "VECTOR4D",
        (pANTLR3_UINT8) "UNITQUATERNION",
        (pANTLR3_UINT8) "QUATERNION",
        (pANTLR3_UINT8) "BOUNDINGSPHERE3F",
        (pANTLR3_UINT8) "BOUNDINGSPHERE3D",
        (pANTLR3_UINT8) "BOUNDINGBOX3F3F",
        (pANTLR3_UINT8) "BOUNDINGBOX3D3F",
        (pANTLR3_UINT8) "UINT8",
        (pANTLR3_UINT8) "INT8",
        (pANTLR3_UINT8) "SINT8",
        (pANTLR3_UINT8) "FIXED8",
        (pANTLR3_UINT8) "SFIXED8",
        (pANTLR3_UINT8) "INT16",
        (pANTLR3_UINT8) "SINT16",
        (pANTLR3_UINT8) "FIXED16",
        (pANTLR3_UINT8) "SFIXED16",
        (pANTLR3_UINT8) "UINT16",
        (pANTLR3_UINT8) "ANGLE",
        (pANTLR3_UINT8) "TIME",
        (pANTLR3_UINT8) "DURATION",
        (pANTLR3_UINT8) "UUID",
        (pANTLR3_UINT8) "SHA256",
        (pANTLR3_UINT8) "HEX_LITERAL",
        (pANTLR3_UINT8) "DECIMAL_LITERAL",
        (pANTLR3_UINT8) "OCTAL_LITERAL",
        (pANTLR3_UINT8) "FLOATING_POINT_LITERAL",
        (pANTLR3_UINT8) "BOOL_LITERAL",
        (pANTLR3_UINT8) "FLAGS8",
        (pANTLR3_UINT8) "FLAGS16",
        (pANTLR3_UINT8) "FLAGS32",
        (pANTLR3_UINT8) "FLAGS64",
        (pANTLR3_UINT8) "STRING_GUTS",
        (pANTLR3_UINT8) "EscapeSequence",
        (pANTLR3_UINT8) "HexDigit",
        (pANTLR3_UINT8) "Exponent",
        (pANTLR3_UINT8) "OctalEscape",
        (pANTLR3_UINT8) "UnicodeEscape",
        (pANTLR3_UINT8) "IDENTIFIERCOLON",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "QUOTE",
        (pANTLR3_UINT8) "COLON"
       };

        
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pProtoJSParser_messageStack
 */
void
pProtoJSParser_messagePop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(message)->free != NULL)
	{
        SCOPE_TOP(message)->free(SCOPE_TOP(message));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_messageStack_limit--;
    SCOPE_TOP(message) = (pProtoJSParser_message_SCOPE)(ctx->pProtoJSParser_messageStack->get(ctx->pProtoJSParser_messageStack, ctx->pProtoJSParser_messageStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pProtoJSParser_enum_defStack
 */
void
pProtoJSParser_enum_defPop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(enum_def)->free != NULL)
	{
        SCOPE_TOP(enum_def)->free(SCOPE_TOP(enum_def));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_enum_defStack_limit--;
    SCOPE_TOP(enum_def) = (pProtoJSParser_enum_def_SCOPE)(ctx->pProtoJSParser_enum_defStack->get(ctx->pProtoJSParser_enum_defStack, ctx->pProtoJSParser_enum_defStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pProtoJSParser_flags_defStack
 */
void
pProtoJSParser_flags_defPop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(flags_def)->free != NULL)
	{
        SCOPE_TOP(flags_def)->free(SCOPE_TOP(flags_def));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_flags_defStack_limit--;
    SCOPE_TOP(flags_def) = (pProtoJSParser_flags_def_SCOPE)(ctx->pProtoJSParser_flags_defStack->get(ctx->pProtoJSParser_flags_defStack, ctx->pProtoJSParser_flags_defStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pProtoJSParser_fieldStack
 */
void
pProtoJSParser_fieldPop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(field)->free != NULL)
	{
        SCOPE_TOP(field)->free(SCOPE_TOP(field));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_fieldStack_limit--;
    SCOPE_TOP(field) = (pProtoJSParser_field_SCOPE)(ctx->pProtoJSParser_fieldStack->get(ctx->pProtoJSParser_fieldStack, ctx->pProtoJSParser_fieldStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pProtoJSParser_option_pairStack
 */
void
pProtoJSParser_option_pairPop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(option_pair)->free != NULL)
	{
        SCOPE_TOP(option_pair)->free(SCOPE_TOP(option_pair));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_option_pairStack_limit--;
    SCOPE_TOP(option_pair) = (pProtoJSParser_option_pair_SCOPE)(ctx->pProtoJSParser_option_pairStack->get(ctx->pProtoJSParser_option_pairStack, ctx->pProtoJSParser_option_pairStack_limit - 1));
}

/* globalAttributeScopeFuncMacro(scope)
 */
/** Function  for popping the top value from a pProtoJSParser_SymbolsStack
 */
void
pProtoJSParser_SymbolsPop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(Symbols)->free != NULL)
	{
        SCOPE_TOP(Symbols)->free(SCOPE_TOP(Symbols));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_SymbolsStack_limit--;
    SCOPE_TOP(Symbols) = (pProtoJSParser_Symbols_SCOPE)(ctx->pProtoJSParser_SymbolsStack->get(ctx->pProtoJSParser_SymbolsStack, ctx->pProtoJSParser_SymbolsStack_limit - 1));
}/* globalAttributeScopeFuncMacro(scope)
 */
/** Function  for popping the top value from a pProtoJSParser_NameSpaceStack
 */
void
pProtoJSParser_NameSpacePop(pProtoJSParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(NameSpace)->free != NULL)
	{
        SCOPE_TOP(NameSpace)->free(SCOPE_TOP(NameSpace));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pProtoJSParser_NameSpaceStack_limit--;
    SCOPE_TOP(NameSpace) = (pProtoJSParser_NameSpace_SCOPE)(ctx->pProtoJSParser_NameSpaceStack->get(ctx->pProtoJSParser_NameSpaceStack, ctx->pProtoJSParser_NameSpaceStack_limit - 1));
}

// Forward declare the locally static matching functions we have generated.
//
static ProtoJSParser_protocol_return	protocol    (pProtoJSParser ctx);
static ProtoJSParser_protoroot_return	protoroot    (pProtoJSParser ctx);
static ProtoJSParser_pbj_header_return	pbj_header    (pProtoJSParser ctx);
static ProtoJSParser_package_return	package    (pProtoJSParser ctx);
static ProtoJSParser_packagename_return	packagename    (pProtoJSParser ctx);
static ProtoJSParser_importrule_return	importrule    (pProtoJSParser ctx);
static ProtoJSParser_service_return	service    (pProtoJSParser ctx);
static ProtoJSParser_service_block_return	service_block    (pProtoJSParser ctx);
static ProtoJSParser_service_args_return	service_args    (pProtoJSParser ctx);
static ProtoJSParser_message_return	message    (pProtoJSParser ctx);
static ProtoJSParser_message_not_extend_return	message_not_extend    (pProtoJSParser ctx);
static ProtoJSParser_extend_not_message_return	extend_not_message    (pProtoJSParser ctx);
static ProtoJSParser_message_identifier_return	message_identifier    (pProtoJSParser ctx);
static ProtoJSParser_at_least_one_message_element_return	at_least_one_message_element    (pProtoJSParser ctx);
static ProtoJSParser_zero_or_more_message_elements_return	zero_or_more_message_elements    (pProtoJSParser ctx);
static ProtoJSParser_newline_message_element_return	newline_message_element    (pProtoJSParser ctx);
static ProtoJSParser_message_element_return	message_element    (pProtoJSParser ctx);
static ProtoJSParser_extensions_return	extensions    (pProtoJSParser ctx);
static ProtoJSParser_reservations_return	reservations    (pProtoJSParser ctx);
static ProtoJSParser_integer_inclusive_return	integer_inclusive    (pProtoJSParser ctx);
static ProtoJSParser_enum_def_return	enum_def    (pProtoJSParser ctx);
static ProtoJSParser_at_least_one_enum_element_return	at_least_one_enum_element    (pProtoJSParser ctx);
static ProtoJSParser_zero_or_more_enum_elements_return	zero_or_more_enum_elements    (pProtoJSParser ctx);
static ProtoJSParser_enum_element_return	enum_element    (pProtoJSParser ctx);
static ProtoJSParser_enum_identifier_return	enum_identifier    (pProtoJSParser ctx);
static ProtoJSParser_flags_def_return	flags_def    (pProtoJSParser ctx);
static ProtoJSParser_flag_identifier_return	flag_identifier    (pProtoJSParser ctx);
static ProtoJSParser_at_least_one_flag_element_return	at_least_one_flag_element    (pProtoJSParser ctx);
static ProtoJSParser_zero_or_more_flag_elements_return	zero_or_more_flag_elements    (pProtoJSParser ctx);
static ProtoJSParser_flag_element_return	flag_element    (pProtoJSParser ctx);
static ProtoJSParser_field_return	field    (pProtoJSParser ctx);
static ProtoJSParser_multiplicity_return	multiplicity    (pProtoJSParser ctx);
static ProtoJSParser_none_return	none    (pProtoJSParser ctx);
static ProtoJSParser_field_offset_return	field_offset    (pProtoJSParser ctx);
static ProtoJSParser_field_name_return	field_name    (pProtoJSParser ctx);
static ProtoJSParser_field_type_return	field_type    (pProtoJSParser ctx);
static ProtoJSParser_type_identifier_return	type_identifier    (pProtoJSParser ctx);
static ProtoJSParser_multiplicitive_type_return	multiplicitive_type    (pProtoJSParser ctx);
static ProtoJSParser_array_spec_return	array_spec    (pProtoJSParser ctx);
static ProtoJSParser_option_assignment_return	option_assignment    (pProtoJSParser ctx);
static ProtoJSParser_option_assignment_value_return	option_assignment_value    (pProtoJSParser ctx);
static ProtoJSParser_default_value_return	default_value    (pProtoJSParser ctx);
static ProtoJSParser_option_pairs_return	option_pairs    (pProtoJSParser ctx);
static ProtoJSParser_option_pair_return	option_pair    (pProtoJSParser ctx);
static ProtoJSParser_option_literal_value_return	option_literal_value    (pProtoJSParser ctx);
static ProtoJSParser_default_literal_value_return	default_literal_value    (pProtoJSParser ctx);
static ProtoJSParser_floating_point_type_return	floating_point_type    (pProtoJSParser ctx);
static ProtoJSParser_double_floating_point_type_return	double_floating_point_type    (pProtoJSParser ctx);
static ProtoJSParser_numeric_type_return	numeric_type    (pProtoJSParser ctx);
static ProtoJSParser_array_type_return	array_type    (pProtoJSParser ctx);
static ProtoJSParser_multiplicitive_advanced_type_return	multiplicitive_advanced_type    (pProtoJSParser ctx);
static ProtoJSParser_advanced_numeric_type_return	advanced_numeric_type    (pProtoJSParser ctx);
static ProtoJSParser_advanced_array_type_return	advanced_array_type    (pProtoJSParser ctx);
static ProtoJSParser_literal_value_return	literal_value    (pProtoJSParser ctx);
static ProtoJSParser_flags_return	flags    (pProtoJSParser ctx);
static ProtoJSParser_integer_return	integer    (pProtoJSParser ctx);
static void	ProtoJSParserFree(pProtoJSParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "ProtoJS.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new ProtoJSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pProtoJSParser
ProtoJSParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return ProtoJSParserNewSSD(instream, NULL);
}

/** \brief Create a new ProtoJSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pProtoJSParser
ProtoJSParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pProtoJSParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pProtoJSParser) ANTLR3_CALLOC(1, sizeof(ProtoJSParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in ProtoJSParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our ProtoJSParser interface
     */
    ctx->protocol	= protocol;
    ctx->protoroot	= protoroot;
    ctx->pbj_header	= pbj_header;
    ctx->package	= package;
    ctx->packagename	= packagename;
    ctx->importrule	= importrule;
    ctx->service	= service;
    ctx->service_block	= service_block;
    ctx->service_args	= service_args;
    ctx->message	= message;
    ctx->message_not_extend	= message_not_extend;
    ctx->extend_not_message	= extend_not_message;
    ctx->message_identifier	= message_identifier;
    ctx->at_least_one_message_element	= at_least_one_message_element;
    ctx->zero_or_more_message_elements	= zero_or_more_message_elements;
    ctx->newline_message_element	= newline_message_element;
    ctx->message_element	= message_element;
    ctx->extensions	= extensions;
    ctx->reservations	= reservations;
    ctx->integer_inclusive	= integer_inclusive;
    ctx->enum_def	= enum_def;
    ctx->at_least_one_enum_element	= at_least_one_enum_element;
    ctx->zero_or_more_enum_elements	= zero_or_more_enum_elements;
    ctx->enum_element	= enum_element;
    ctx->enum_identifier	= enum_identifier;
    ctx->flags_def	= flags_def;
    ctx->flag_identifier	= flag_identifier;
    ctx->at_least_one_flag_element	= at_least_one_flag_element;
    ctx->zero_or_more_flag_elements	= zero_or_more_flag_elements;
    ctx->flag_element	= flag_element;
    ctx->field	= field;
    ctx->multiplicity	= multiplicity;
    ctx->none	= none;
    ctx->field_offset	= field_offset;
    ctx->field_name	= field_name;
    ctx->field_type	= field_type;
    ctx->type_identifier	= type_identifier;
    ctx->multiplicitive_type	= multiplicitive_type;
    ctx->array_spec	= array_spec;
    ctx->option_assignment	= option_assignment;
    ctx->option_assignment_value	= option_assignment_value;
    ctx->default_value	= default_value;
    ctx->option_pairs	= option_pairs;
    ctx->option_pair	= option_pair;
    ctx->option_literal_value	= option_literal_value;
    ctx->default_literal_value	= default_literal_value;
    ctx->floating_point_type	= floating_point_type;
    ctx->double_floating_point_type	= double_floating_point_type;
    ctx->numeric_type	= numeric_type;
    ctx->array_type	= array_type;
    ctx->multiplicitive_advanced_type	= multiplicitive_advanced_type;
    ctx->advanced_numeric_type	= advanced_numeric_type;
    ctx->advanced_array_type	= advanced_array_type;
    ctx->literal_value	= literal_value;
    ctx->flags	= flags;
    ctx->integer	= integer;
    ctx->free			= ProtoJSParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_messagePush     = pProtoJSParser_messagePush;
    ctx->pProtoJSParser_messageStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_messageStack_limit    = 0;
    ctx->pProtoJSParser_messageTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_enum_defPush     = pProtoJSParser_enum_defPush;
    ctx->pProtoJSParser_enum_defStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_enum_defStack_limit    = 0;
    ctx->pProtoJSParser_enum_defTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_flags_defPush     = pProtoJSParser_flags_defPush;
    ctx->pProtoJSParser_flags_defStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_flags_defStack_limit    = 0;
    ctx->pProtoJSParser_flags_defTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_fieldPush     = pProtoJSParser_fieldPush;
    ctx->pProtoJSParser_fieldStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_fieldStack_limit    = 0;
    ctx->pProtoJSParser_fieldTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_option_pairPush     = pProtoJSParser_option_pairPush;
    ctx->pProtoJSParser_option_pairStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_option_pairStack_limit    = 0;
    ctx->pProtoJSParser_option_pairTop      = NULL;

    /* globalAttributeScope(scope)
     */
    ctx->pProtoJSParser_SymbolsPush     = pProtoJSParser_SymbolsPush;
    ctx->pProtoJSParser_SymbolsStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_SymbolsStack_limit    = 0;
    ctx->pProtoJSParser_SymbolsTop      = NULL;
    /* globalAttributeScope(scope)
     */
    ctx->pProtoJSParser_NameSpacePush     = pProtoJSParser_NameSpacePush;
    ctx->pProtoJSParser_NameSpaceStack    = antlr3StackNew(0);
    ctx->pProtoJSParser_NameSpaceStack_limit    = 0;
    ctx->pProtoJSParser_NameSpaceTop      = NULL;

    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);
    ctx->vectors	= antlr3VectorFactoryNew(0);
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = ProtoJSParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 ProtoJSParserFree(pProtoJSParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_messageStack->free(ctx->pProtoJSParser_messageStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_enum_defStack->free(ctx->pProtoJSParser_enum_defStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_flags_defStack->free(ctx->pProtoJSParser_flags_defStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_fieldStack->free(ctx->pProtoJSParser_fieldStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pProtoJSParser_option_pairStack->free(ctx->pProtoJSParser_option_pairStack);

    /* globalAttributeScope(scope)  
     */
    ctx->pProtoJSParser_SymbolsStack->free(ctx->pProtoJSParser_SymbolsStack);
    /* globalAttributeScope(scope)  
     */
    ctx->pProtoJSParser_NameSpaceStack->free(ctx->pProtoJSParser_NameSpaceStack);

    
    ctx->vectors->close(ctx->vectors);
    /* We created the adaptor so we must free it
     */
    ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return ProtoJSParserTokenNames; 
}


        #include "ProtoJSParseUtil.h"

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_protoroot_in_protocol104  */
static	ANTLR3_BITWORD FOLLOW_protoroot_in_protocol104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_protoroot_in_protocol104	= { FOLLOW_protoroot_in_protocol104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pbj_header_in_protoroot152  */
static	ANTLR3_BITWORD FOLLOW_pbj_header_in_protoroot152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_pbj_header_in_protoroot152	= { FOLLOW_pbj_header_in_protoroot152_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_importrule_in_protoroot156  */
static	ANTLR3_BITWORD FOLLOW_importrule_in_protoroot156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_importrule_in_protoroot156	= { FOLLOW_importrule_in_protoroot156_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_in_protoroot158  */
static	ANTLR3_BITWORD FOLLOW_message_in_protoroot158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_message_in_protoroot158	= { FOLLOW_message_in_protoroot158_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_in_protoroot160  */
static	ANTLR3_BITWORD FOLLOW_service_in_protoroot160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_service_in_protoroot160	= { FOLLOW_service_in_protoroot160_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_def_in_protoroot162  */
static	ANTLR3_BITWORD FOLLOW_enum_def_in_protoroot162_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_def_in_protoroot162	= { FOLLOW_enum_def_in_protoroot162_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flags_def_in_protoroot164  */
static	ANTLR3_BITWORD FOLLOW_flags_def_in_protoroot164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_flags_def_in_protoroot164	= { FOLLOW_flags_def_in_protoroot164_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_assignment_in_protoroot166  */
static	ANTLR3_BITWORD FOLLOW_option_assignment_in_protoroot166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C42), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_option_assignment_in_protoroot166	= { FOLLOW_option_assignment_in_protoroot166_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_package_in_protoroot171  */
static	ANTLR3_BITWORD FOLLOW_package_in_protoroot171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_package_in_protoroot171	= { FOLLOW_package_in_protoroot171_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_importrule_in_protoroot174  */
static	ANTLR3_BITWORD FOLLOW_importrule_in_protoroot174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_importrule_in_protoroot174	= { FOLLOW_importrule_in_protoroot174_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_in_protoroot176  */
static	ANTLR3_BITWORD FOLLOW_message_in_protoroot176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_message_in_protoroot176	= { FOLLOW_message_in_protoroot176_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_in_protoroot178  */
static	ANTLR3_BITWORD FOLLOW_service_in_protoroot178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_service_in_protoroot178	= { FOLLOW_service_in_protoroot178_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_def_in_protoroot180  */
static	ANTLR3_BITWORD FOLLOW_enum_def_in_protoroot180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_def_in_protoroot180	= { FOLLOW_enum_def_in_protoroot180_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flags_def_in_protoroot182  */
static	ANTLR3_BITWORD FOLLOW_flags_def_in_protoroot182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_flags_def_in_protoroot182	= { FOLLOW_flags_def_in_protoroot182_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_assignment_in_protoroot184  */
static	ANTLR3_BITWORD FOLLOW_option_assignment_in_protoroot184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000101180C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_option_assignment_in_protoroot184	= { FOLLOW_option_assignment_in_protoroot184_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_pbj_header204  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_pbj_header204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_pbj_header204	= { FOLLOW_STRING_LITERAL_in_pbj_header204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PACKAGELITERAL_in_package253  */
static	ANTLR3_BITWORD FOLLOW_PACKAGELITERAL_in_package253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET_LIST FOLLOW_PACKAGELITERAL_in_package253	= { FOLLOW_PACKAGELITERAL_in_package253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_packagename_in_package255  */
static	ANTLR3_BITWORD FOLLOW_packagename_in_package255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_packagename_in_package255	= { FOLLOW_packagename_in_package255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_package257  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_package257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_package257	= { FOLLOW_ITEM_TERMINATOR_in_package257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUALIFIEDIDENTIFIER_in_packagename282  */
static	ANTLR3_BITWORD FOLLOW_QUALIFIEDIDENTIFIER_in_packagename282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUALIFIEDIDENTIFIER_in_packagename282	= { FOLLOW_QUALIFIEDIDENTIFIER_in_packagename282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_packagename297  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_packagename297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_packagename297	= { FOLLOW_IDENTIFIER_in_packagename297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPORTLITERAL_in_importrule322  */
static	ANTLR3_BITWORD FOLLOW_IMPORTLITERAL_in_importrule322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPORTLITERAL_in_importrule322	= { FOLLOW_IMPORTLITERAL_in_importrule322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_importrule324  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_importrule324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_importrule324	= { FOLLOW_STRING_LITERAL_in_importrule324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_importrule326  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_importrule326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_importrule326	= { FOLLOW_ITEM_TERMINATOR_in_importrule326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SERVICE_in_service365  */
static	ANTLR3_BITWORD FOLLOW_SERVICE_in_service365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SERVICE_in_service365	= { FOLLOW_SERVICE_in_service365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_service367  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_service367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_service367	= { FOLLOW_IDENTIFIER_in_service367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_OPEN_in_service369  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_OPEN_in_service369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000006000) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_OPEN_in_service369	= { FOLLOW_BLOCK_OPEN_in_service369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_block_in_service371  */
static	ANTLR3_BITWORD FOLLOW_service_block_in_service371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000006000) };
static  ANTLR3_BITSET_LIST FOLLOW_service_block_in_service371	= { FOLLOW_service_block_in_service371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_CLOSE_in_service374  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_CLOSE_in_service374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_CLOSE_in_service374	= { FOLLOW_BLOCK_CLOSE_in_service374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPC_in_service_block389  */
static	ANTLR3_BITWORD FOLLOW_RPC_in_service_block389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_RPC_in_service_block389	= { FOLLOW_RPC_in_service_block389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_service_block391  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_service_block391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_service_block391	= { FOLLOW_IDENTIFIER_in_service_block391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_OPEN_in_service_block393  */
static	ANTLR3_BITWORD FOLLOW_PAREN_OPEN_in_service_block393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010200) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_OPEN_in_service_block393	= { FOLLOW_PAREN_OPEN_in_service_block393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_args_in_service_block395  */
static	ANTLR3_BITWORD FOLLOW_service_args_in_service_block395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_service_args_in_service_block395	= { FOLLOW_service_args_in_service_block395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_CLOSE_in_service_block398  */
static	ANTLR3_BITWORD FOLLOW_PAREN_CLOSE_in_service_block398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_CLOSE_in_service_block398	= { FOLLOW_PAREN_CLOSE_in_service_block398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURNS_in_service_block400  */
static	ANTLR3_BITWORD FOLLOW_RETURNS_in_service_block400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURNS_in_service_block400	= { FOLLOW_RETURNS_in_service_block400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_OPEN_in_service_block402  */
static	ANTLR3_BITWORD FOLLOW_PAREN_OPEN_in_service_block402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_OPEN_in_service_block402	= { FOLLOW_PAREN_OPEN_in_service_block402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_service_block404  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_service_block404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_service_block404	= { FOLLOW_IDENTIFIER_in_service_block404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_CLOSE_in_service_block406  */
static	ANTLR3_BITWORD FOLLOW_PAREN_CLOSE_in_service_block406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_CLOSE_in_service_block406	= { FOLLOW_PAREN_CLOSE_in_service_block406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_service_block408  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_service_block408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_service_block408	= { FOLLOW_ITEM_TERMINATOR_in_service_block408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_service_args416  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_service_args416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_service_args416	= { FOLLOW_IDENTIFIER_in_service_args416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_service_args419  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_service_args419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_service_args419	= { FOLLOW_COMMA_in_service_args419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_args_in_service_args421  */
static	ANTLR3_BITWORD FOLLOW_service_args_in_service_args421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_service_args_in_service_args421	= { FOLLOW_service_args_in_service_args421_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_not_extend_in_message453  */
static	ANTLR3_BITWORD FOLLOW_message_not_extend_in_message453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_message_not_extend_in_message453	= { FOLLOW_message_not_extend_in_message453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_identifier_in_message455  */
static	ANTLR3_BITWORD FOLLOW_message_identifier_in_message455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_message_identifier_in_message455	= { FOLLOW_message_identifier_in_message455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_OPEN_in_message457  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_OPEN_in_message457_bits[]	= { ANTLR3_UINT64_LIT(0x000000001DB82000), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_OPEN_in_message457	= { FOLLOW_BLOCK_OPEN_in_message457_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_at_least_one_message_element_in_message460  */
static	ANTLR3_BITWORD FOLLOW_at_least_one_message_element_in_message460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_at_least_one_message_element_in_message460	= { FOLLOW_at_least_one_message_element_in_message460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_CLOSE_in_message464  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_CLOSE_in_message464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_CLOSE_in_message464	= { FOLLOW_BLOCK_CLOSE_in_message464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extend_not_message_in_message641  */
static	ANTLR3_BITWORD FOLLOW_extend_not_message_in_message641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_extend_not_message_in_message641	= { FOLLOW_extend_not_message_in_message641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_identifier_in_message643  */
static	ANTLR3_BITWORD FOLLOW_message_identifier_in_message643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_message_identifier_in_message643	= { FOLLOW_message_identifier_in_message643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_OPEN_in_message645  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_OPEN_in_message645_bits[]	= { ANTLR3_UINT64_LIT(0x000000001DB82000), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_OPEN_in_message645	= { FOLLOW_BLOCK_OPEN_in_message645_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_at_least_one_message_element_in_message648  */
static	ANTLR3_BITWORD FOLLOW_at_least_one_message_element_in_message648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_at_least_one_message_element_in_message648	= { FOLLOW_at_least_one_message_element_in_message648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_CLOSE_in_message652  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_CLOSE_in_message652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_CLOSE_in_message652	= { FOLLOW_BLOCK_CLOSE_in_message652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MESSAGE_in_message_not_extend741  */
static	ANTLR3_BITWORD FOLLOW_MESSAGE_in_message_not_extend741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MESSAGE_in_message_not_extend741	= { FOLLOW_MESSAGE_in_message_not_extend741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTEND_in_extend_not_message769  */
static	ANTLR3_BITWORD FOLLOW_EXTEND_in_extend_not_message769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTEND_in_extend_not_message769	= { FOLLOW_EXTEND_in_extend_not_message769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_message_identifier792  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_message_identifier792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_message_identifier792	= { FOLLOW_IDENTIFIER_in_message_identifier792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_at_least_one_message_element835  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_at_least_one_message_element835_bits[]	= { ANTLR3_UINT64_LIT(0x000000001DB80000), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_at_least_one_message_element835	= { FOLLOW_extensions_in_at_least_one_message_element835_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reservations_in_at_least_one_message_element837  */
static	ANTLR3_BITWORD FOLLOW_reservations_in_at_least_one_message_element837_bits[]	= { ANTLR3_UINT64_LIT(0x000000001DB80000), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_reservations_in_at_least_one_message_element837	= { FOLLOW_reservations_in_at_least_one_message_element837_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_element_in_at_least_one_message_element841  */
static	ANTLR3_BITWORD FOLLOW_message_element_in_at_least_one_message_element841_bits[]	= { ANTLR3_UINT64_LIT(0x000000011DB80C00), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_message_element_in_at_least_one_message_element841	= { FOLLOW_message_element_in_at_least_one_message_element841_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_zero_or_more_message_elements_in_at_least_one_message_element843  */
static	ANTLR3_BITWORD FOLLOW_zero_or_more_message_elements_in_at_least_one_message_element843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_zero_or_more_message_elements_in_at_least_one_message_element843	= { FOLLOW_zero_or_more_message_elements_in_at_least_one_message_element843_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_newline_message_element_in_zero_or_more_message_elements862  */
static	ANTLR3_BITWORD FOLLOW_newline_message_element_in_zero_or_more_message_elements862_bits[]	= { ANTLR3_UINT64_LIT(0x000000011DB80C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_newline_message_element_in_zero_or_more_message_elements862	= { FOLLOW_newline_message_element_in_zero_or_more_message_elements862_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_zero_or_more_message_elements864  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_zero_or_more_message_elements864_bits[]	= { ANTLR3_UINT64_LIT(0x000000011DB80C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_zero_or_more_message_elements864	= { FOLLOW_extensions_in_zero_or_more_message_elements864_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reservations_in_zero_or_more_message_elements866  */
static	ANTLR3_BITWORD FOLLOW_reservations_in_zero_or_more_message_elements866_bits[]	= { ANTLR3_UINT64_LIT(0x000000011DB80C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_reservations_in_zero_or_more_message_elements866	= { FOLLOW_reservations_in_zero_or_more_message_elements866_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_assignment_in_zero_or_more_message_elements868  */
static	ANTLR3_BITWORD FOLLOW_option_assignment_in_zero_or_more_message_elements868_bits[]	= { ANTLR3_UINT64_LIT(0x000000011DB80C02), ANTLR3_UINT64_LIT(0x00000000003C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_option_assignment_in_zero_or_more_message_elements868	= { FOLLOW_option_assignment_in_zero_or_more_message_elements868_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_in_newline_message_element881  */
static	ANTLR3_BITWORD FOLLOW_field_in_newline_message_element881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_field_in_newline_message_element881	= { FOLLOW_field_in_newline_message_element881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_in_newline_message_element898  */
static	ANTLR3_BITWORD FOLLOW_message_in_newline_message_element898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_in_newline_message_element898	= { FOLLOW_message_in_newline_message_element898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_def_in_newline_message_element915  */
static	ANTLR3_BITWORD FOLLOW_enum_def_in_newline_message_element915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_def_in_newline_message_element915	= { FOLLOW_enum_def_in_newline_message_element915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flags_def_in_newline_message_element932  */
static	ANTLR3_BITWORD FOLLOW_flags_def_in_newline_message_element932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_flags_def_in_newline_message_element932	= { FOLLOW_flags_def_in_newline_message_element932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_in_message_element957  */
static	ANTLR3_BITWORD FOLLOW_field_in_message_element957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_field_in_message_element957	= { FOLLOW_field_in_message_element957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_in_message_element962  */
static	ANTLR3_BITWORD FOLLOW_message_in_message_element962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_in_message_element962	= { FOLLOW_message_in_message_element962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_def_in_message_element967  */
static	ANTLR3_BITWORD FOLLOW_enum_def_in_message_element967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_def_in_message_element967	= { FOLLOW_enum_def_in_message_element967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flags_def_in_message_element972  */
static	ANTLR3_BITWORD FOLLOW_flags_def_in_message_element972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_flags_def_in_message_element972	= { FOLLOW_flags_def_in_message_element972_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTENSIONS_in_extensions1001  */
static	ANTLR3_BITWORD FOLLOW_EXTENSIONS_in_extensions1001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTENSIONS_in_extensions1001	= { FOLLOW_EXTENSIONS_in_extensions1001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensions1003  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensions1003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensions1003	= { FOLLOW_integer_in_extensions1003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TO_in_extensions1005  */
static	ANTLR3_BITWORD FOLLOW_TO_in_extensions1005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_TO_in_extensions1005	= { FOLLOW_TO_in_extensions1005_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_inclusive_in_extensions1007  */
static	ANTLR3_BITWORD FOLLOW_integer_inclusive_in_extensions1007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_inclusive_in_extensions1007	= { FOLLOW_integer_inclusive_in_extensions1007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_extensions1009  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_extensions1009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_extensions1009	= { FOLLOW_ITEM_TERMINATOR_in_extensions1009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESERVE_in_reservations1045  */
static	ANTLR3_BITWORD FOLLOW_RESERVE_in_reservations1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_RESERVE_in_reservations1045	= { FOLLOW_RESERVE_in_reservations1045_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_reservations1047  */
static	ANTLR3_BITWORD FOLLOW_integer_in_reservations1047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_reservations1047	= { FOLLOW_integer_in_reservations1047_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TO_in_reservations1049  */
static	ANTLR3_BITWORD FOLLOW_TO_in_reservations1049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_TO_in_reservations1049	= { FOLLOW_TO_in_reservations1049_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_inclusive_in_reservations1051  */
static	ANTLR3_BITWORD FOLLOW_integer_inclusive_in_reservations1051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_inclusive_in_reservations1051	= { FOLLOW_integer_inclusive_in_reservations1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_reservations1053  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_reservations1053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_reservations1053	= { FOLLOW_ITEM_TERMINATOR_in_reservations1053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_integer_inclusive1086  */
static	ANTLR3_BITWORD FOLLOW_integer_in_integer_inclusive1086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_integer_inclusive1086	= { FOLLOW_integer_in_integer_inclusive1086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enum_def1134  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enum_def1134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enum_def1134	= { FOLLOW_ENUM_in_enum_def1134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_identifier_in_enum_def1136  */
static	ANTLR3_BITWORD FOLLOW_enum_identifier_in_enum_def1136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_identifier_in_enum_def1136	= { FOLLOW_enum_identifier_in_enum_def1136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_OPEN_in_enum_def1138  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_OPEN_in_enum_def1138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_OPEN_in_enum_def1138	= { FOLLOW_BLOCK_OPEN_in_enum_def1138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_at_least_one_enum_element_in_enum_def1140  */
static	ANTLR3_BITWORD FOLLOW_at_least_one_enum_element_in_enum_def1140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_at_least_one_enum_element_in_enum_def1140	= { FOLLOW_at_least_one_enum_element_in_enum_def1140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_CLOSE_in_enum_def1142  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_CLOSE_in_enum_def1142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_CLOSE_in_enum_def1142	= { FOLLOW_BLOCK_CLOSE_in_enum_def1142_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_element_in_at_least_one_enum_element1297  */
static	ANTLR3_BITWORD FOLLOW_enum_element_in_at_least_one_enum_element1297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_element_in_at_least_one_enum_element1297	= { FOLLOW_enum_element_in_at_least_one_enum_element1297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_zero_or_more_enum_elements_in_at_least_one_enum_element1299  */
static	ANTLR3_BITWORD FOLLOW_zero_or_more_enum_elements_in_at_least_one_enum_element1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_zero_or_more_enum_elements_in_at_least_one_enum_element1299	= { FOLLOW_zero_or_more_enum_elements_in_at_least_one_enum_element1299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enum_element_in_zero_or_more_enum_elements1307  */
static	ANTLR3_BITWORD FOLLOW_enum_element_in_zero_or_more_enum_elements1307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_enum_element_in_zero_or_more_enum_elements1307	= { FOLLOW_enum_element_in_zero_or_more_enum_elements1307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enum_element1332  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enum_element1332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enum_element1332	= { FOLLOW_IDENTIFIER_in_enum_element1332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_enum_element1334  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_enum_element1334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_enum_element1334	= { FOLLOW_EQUALS_in_enum_element1334_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_enum_element1336  */
static	ANTLR3_BITWORD FOLLOW_integer_in_enum_element1336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_enum_element1336	= { FOLLOW_integer_in_enum_element1336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_enum_element1338  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_enum_element1338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_enum_element1338	= { FOLLOW_ITEM_TERMINATOR_in_enum_element1338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enum_identifier1381  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enum_identifier1381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enum_identifier1381	= { FOLLOW_IDENTIFIER_in_enum_identifier1381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flags_in_flags_def1428  */
static	ANTLR3_BITWORD FOLLOW_flags_in_flags_def1428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_flags_in_flags_def1428	= { FOLLOW_flags_in_flags_def1428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flag_identifier_in_flags_def1430  */
static	ANTLR3_BITWORD FOLLOW_flag_identifier_in_flags_def1430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_flag_identifier_in_flags_def1430	= { FOLLOW_flag_identifier_in_flags_def1430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_OPEN_in_flags_def1432  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_OPEN_in_flags_def1432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_OPEN_in_flags_def1432	= { FOLLOW_BLOCK_OPEN_in_flags_def1432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_at_least_one_flag_element_in_flags_def1434  */
static	ANTLR3_BITWORD FOLLOW_at_least_one_flag_element_in_flags_def1434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_at_least_one_flag_element_in_flags_def1434	= { FOLLOW_at_least_one_flag_element_in_flags_def1434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_CLOSE_in_flags_def1436  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_CLOSE_in_flags_def1436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_CLOSE_in_flags_def1436	= { FOLLOW_BLOCK_CLOSE_in_flags_def1436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_flag_identifier1598  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_flag_identifier1598_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_flag_identifier1598	= { FOLLOW_IDENTIFIER_in_flag_identifier1598_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flag_element_in_at_least_one_flag_element1616  */
static	ANTLR3_BITWORD FOLLOW_flag_element_in_at_least_one_flag_element1616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_flag_element_in_at_least_one_flag_element1616	= { FOLLOW_flag_element_in_at_least_one_flag_element1616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_zero_or_more_flag_elements_in_at_least_one_flag_element1618  */
static	ANTLR3_BITWORD FOLLOW_zero_or_more_flag_elements_in_at_least_one_flag_element1618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_zero_or_more_flag_elements_in_at_least_one_flag_element1618	= { FOLLOW_zero_or_more_flag_elements_in_at_least_one_flag_element1618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flag_element_in_zero_or_more_flag_elements1627  */
static	ANTLR3_BITWORD FOLLOW_flag_element_in_zero_or_more_flag_elements1627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_flag_element_in_zero_or_more_flag_elements1627	= { FOLLOW_flag_element_in_zero_or_more_flag_elements1627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_flag_element1652  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_flag_element1652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_flag_element1652	= { FOLLOW_IDENTIFIER_in_flag_element1652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_flag_element1654  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_flag_element1654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_flag_element1654	= { FOLLOW_EQUALS_in_flag_element1654_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_flag_element1656  */
static	ANTLR3_BITWORD FOLLOW_integer_in_flag_element1656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_flag_element1656	= { FOLLOW_integer_in_flag_element1656_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_flag_element1658  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_flag_element1658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_flag_element1658	= { FOLLOW_ITEM_TERMINATOR_in_flag_element1658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicity_in_field1730  */
static	ANTLR3_BITWORD FOLLOW_multiplicity_in_field1730_bits[]	= { ANTLR3_UINT64_LIT(0xFFFFFFFC00000300), ANTLR3_UINT64_LIT(0x0000000000001FFF) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicity_in_field1730	= { FOLLOW_multiplicity_in_field1730_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicitive_type_in_field1733  */
static	ANTLR3_BITWORD FOLLOW_multiplicitive_type_in_field1733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicitive_type_in_field1733	= { FOLLOW_multiplicitive_type_in_field1733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_type_in_field1735  */
static	ANTLR3_BITWORD FOLLOW_field_type_in_field1735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_field_type_in_field1735	= { FOLLOW_field_type_in_field1735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_name_in_field1738  */
static	ANTLR3_BITWORD FOLLOW_field_name_in_field1738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_field_name_in_field1738	= { FOLLOW_field_name_in_field1738_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_field1740  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_field1740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_field1740	= { FOLLOW_EQUALS_in_field1740_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_offset_in_field1742  */
static	ANTLR3_BITWORD FOLLOW_field_offset_in_field1742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000080) };
static  ANTLR3_BITSET_LIST FOLLOW_field_offset_in_field1742	= { FOLLOW_field_offset_in_field1742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_default_value_in_field1745  */
static	ANTLR3_BITWORD FOLLOW_default_value_in_field1745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_default_value_in_field1745	= { FOLLOW_default_value_in_field1745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_none_in_field1747  */
static	ANTLR3_BITWORD FOLLOW_none_in_field1747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_none_in_field1747	= { FOLLOW_none_in_field1747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_field1750  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_field1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_field1750	= { FOLLOW_ITEM_TERMINATOR_in_field1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ProtoJSOPTIONAL_in_multiplicity1885  */
static	ANTLR3_BITWORD FOLLOW_ProtoJSOPTIONAL_in_multiplicity1885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ProtoJSOPTIONAL_in_multiplicity1885	= { FOLLOW_ProtoJSOPTIONAL_in_multiplicity1885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REQUIRED_in_multiplicity1895  */
static	ANTLR3_BITWORD FOLLOW_REQUIRED_in_multiplicity1895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REQUIRED_in_multiplicity1895	= { FOLLOW_REQUIRED_in_multiplicity1895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPEATED_in_multiplicity1923  */
static	ANTLR3_BITWORD FOLLOW_REPEATED_in_multiplicity1923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REPEATED_in_multiplicity1923	= { FOLLOW_REPEATED_in_multiplicity1923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_none1943  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_none1943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_none1943	= { FOLLOW_DOT_in_none1943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_offset1960  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_offset1960_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_offset1960	= { FOLLOW_integer_in_field_offset1960_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_field_name1983  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_field_name1983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_field_name1983	= { FOLLOW_IDENTIFIER_in_field_name1983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numeric_type_in_field_type2007  */
static	ANTLR3_BITWORD FOLLOW_numeric_type_in_field_type2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numeric_type_in_field_type2007	= { FOLLOW_numeric_type_in_field_type2007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_floating_point_type_in_field_type2029  */
static	ANTLR3_BITWORD FOLLOW_floating_point_type_in_field_type2029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_floating_point_type_in_field_type2029	= { FOLLOW_floating_point_type_in_field_type2029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_double_floating_point_type_in_field_type2053  */
static	ANTLR3_BITWORD FOLLOW_double_floating_point_type_in_field_type2053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_double_floating_point_type_in_field_type2053	= { FOLLOW_double_floating_point_type_in_field_type2053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_array_type_in_field_type2077  */
static	ANTLR3_BITWORD FOLLOW_array_type_in_field_type2077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_array_type_in_field_type2077	= { FOLLOW_array_type_in_field_type2077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_advanced_numeric_type_in_field_type2100  */
static	ANTLR3_BITWORD FOLLOW_advanced_numeric_type_in_field_type2100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_advanced_numeric_type_in_field_type2100	= { FOLLOW_advanced_numeric_type_in_field_type2100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_advanced_array_type_in_field_type2123  */
static	ANTLR3_BITWORD FOLLOW_advanced_array_type_in_field_type2123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_advanced_array_type_in_field_type2123	= { FOLLOW_advanced_array_type_in_field_type2123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_identifier_in_field_type2147  */
static	ANTLR3_BITWORD FOLLOW_type_identifier_in_field_type2147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_type_identifier_in_field_type2147	= { FOLLOW_type_identifier_in_field_type2147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_type_identifier0  */
static	ANTLR3_BITWORD FOLLOW_set_in_type_identifier0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_type_identifier0	= { FOLLOW_set_in_type_identifier0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplicitive_advanced_type_in_multiplicitive_type2204  */
static	ANTLR3_BITWORD FOLLOW_multiplicitive_advanced_type_in_multiplicitive_type2204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplicitive_advanced_type_in_multiplicitive_type2204	= { FOLLOW_multiplicitive_advanced_type_in_multiplicitive_type2204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SQBRACKET_OPEN_in_array_spec2232  */
static	ANTLR3_BITWORD FOLLOW_SQBRACKET_OPEN_in_array_spec2232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000), ANTLR3_UINT64_LIT(0x000000000000E000) };
static  ANTLR3_BITSET_LIST FOLLOW_SQBRACKET_OPEN_in_array_spec2232	= { FOLLOW_SQBRACKET_OPEN_in_array_spec2232_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_array_spec2234  */
static	ANTLR3_BITWORD FOLLOW_integer_in_array_spec2234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_array_spec2234	= { FOLLOW_integer_in_array_spec2234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SQBRACKET_CLOSE_in_array_spec2237  */
static	ANTLR3_BITWORD FOLLOW_SQBRACKET_CLOSE_in_array_spec2237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SQBRACKET_CLOSE_in_array_spec2237	= { FOLLOW_SQBRACKET_CLOSE_in_array_spec2237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPTION_LITERAL_in_option_assignment2255  */
static	ANTLR3_BITWORD FOLLOW_OPTION_LITERAL_in_option_assignment2255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008200) };
static  ANTLR3_BITSET_LIST FOLLOW_OPTION_LITERAL_in_option_assignment2255	= { FOLLOW_OPTION_LITERAL_in_option_assignment2255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_OPEN_in_option_assignment2257  */
static	ANTLR3_BITWORD FOLLOW_PAREN_OPEN_in_option_assignment2257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_OPEN_in_option_assignment2257	= { FOLLOW_PAREN_OPEN_in_option_assignment2257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_option_assignment2260  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_option_assignment2260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_option_assignment2260	= { FOLLOW_IDENTIFIER_in_option_assignment2260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PAREN_CLOSE_in_option_assignment2262  */
static	ANTLR3_BITWORD FOLLOW_PAREN_CLOSE_in_option_assignment2262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PAREN_CLOSE_in_option_assignment2262	= { FOLLOW_PAREN_CLOSE_in_option_assignment2262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_option_assignment2265  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_option_assignment2265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000320), ANTLR3_UINT64_LIT(0x000000000003E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_option_assignment2265	= { FOLLOW_EQUALS_in_option_assignment2265_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_assignment_value_in_option_assignment2267  */
static	ANTLR3_BITWORD FOLLOW_option_assignment_value_in_option_assignment2267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_option_assignment_value_in_option_assignment2267	= { FOLLOW_option_assignment_value_in_option_assignment2267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITEM_TERMINATOR_in_option_assignment2269  */
static	ANTLR3_BITWORD FOLLOW_ITEM_TERMINATOR_in_option_assignment2269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ITEM_TERMINATOR_in_option_assignment2269	= { FOLLOW_ITEM_TERMINATOR_in_option_assignment2269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_value_in_option_assignment_value2292  */
static	ANTLR3_BITWORD FOLLOW_literal_value_in_option_assignment_value2292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_value_in_option_assignment_value2292	= { FOLLOW_literal_value_in_option_assignment_value2292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUALIFIEDIDENTIFIER_in_option_assignment_value2294  */
static	ANTLR3_BITWORD FOLLOW_QUALIFIEDIDENTIFIER_in_option_assignment_value2294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUALIFIEDIDENTIFIER_in_option_assignment_value2294	= { FOLLOW_QUALIFIEDIDENTIFIER_in_option_assignment_value2294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_option_assignment_value2296  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_option_assignment_value2296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_option_assignment_value2296	= { FOLLOW_IDENTIFIER_in_option_assignment_value2296_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SQBRACKET_OPEN_in_default_value2313  */
static	ANTLR3_BITWORD FOLLOW_SQBRACKET_OPEN_in_default_value2313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SQBRACKET_OPEN_in_default_value2313	= { FOLLOW_SQBRACKET_OPEN_in_default_value2313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_pairs_in_default_value2315  */
static	ANTLR3_BITWORD FOLLOW_option_pairs_in_default_value2315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_option_pairs_in_default_value2315	= { FOLLOW_option_pairs_in_default_value2315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SQBRACKET_CLOSE_in_default_value2317  */
static	ANTLR3_BITWORD FOLLOW_SQBRACKET_CLOSE_in_default_value2317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SQBRACKET_CLOSE_in_default_value2317	= { FOLLOW_SQBRACKET_CLOSE_in_default_value2317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_pair_in_option_pairs2388  */
static	ANTLR3_BITWORD FOLLOW_option_pair_in_option_pairs2388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_option_pair_in_option_pairs2388	= { FOLLOW_option_pair_in_option_pairs2388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_option_pairs2391  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_option_pairs2391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_option_pairs2391	= { FOLLOW_COMMA_in_option_pairs2391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_pair_in_option_pairs2393  */
static	ANTLR3_BITWORD FOLLOW_option_pair_in_option_pairs2393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040002) };
static  ANTLR3_BITSET_LIST FOLLOW_option_pair_in_option_pairs2393	= { FOLLOW_option_pair_in_option_pairs2393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_in_option_pair2427  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_in_option_pair2427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_in_option_pair2427	= { FOLLOW_DEFAULT_in_option_pair2427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_option_pair2429  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_option_pair2429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000220), ANTLR3_UINT64_LIT(0x000000000003E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_option_pair2429	= { FOLLOW_EQUALS_in_option_pair2429_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_default_literal_value_in_option_pair2431  */
static	ANTLR3_BITWORD FOLLOW_default_literal_value_in_option_pair2431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_default_literal_value_in_option_pair2431	= { FOLLOW_default_literal_value_in_option_pair2431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_option_pair2456  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_option_pair2456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_option_pair2456	= { FOLLOW_IDENTIFIER_in_option_pair2456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUALS_in_option_pair2458  */
static	ANTLR3_BITWORD FOLLOW_EQUALS_in_option_pair2458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020), ANTLR3_UINT64_LIT(0x000000000003E000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUALS_in_option_pair2458	= { FOLLOW_EQUALS_in_option_pair2458_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_option_literal_value_in_option_pair2460  */
static	ANTLR3_BITWORD FOLLOW_option_literal_value_in_option_pair2460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_option_literal_value_in_option_pair2460	= { FOLLOW_option_literal_value_in_option_pair2460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_value_in_option_literal_value2526  */
static	ANTLR3_BITWORD FOLLOW_literal_value_in_option_literal_value2526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_value_in_option_literal_value2526	= { FOLLOW_literal_value_in_option_literal_value2526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_value_in_default_literal_value2540  */
static	ANTLR3_BITWORD FOLLOW_literal_value_in_default_literal_value2540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_value_in_default_literal_value2540	= { FOLLOW_literal_value_in_default_literal_value2540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_default_literal_value2554  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_default_literal_value2554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_default_literal_value2554	= { FOLLOW_IDENTIFIER_in_default_literal_value2554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLOAT_in_floating_point_type2569  */
static	ANTLR3_BITWORD FOLLOW_FLOAT_in_floating_point_type2569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLOAT_in_floating_point_type2569	= { FOLLOW_FLOAT_in_floating_point_type2569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOUBLE_in_double_floating_point_type2575  */
static	ANTLR3_BITWORD FOLLOW_DOUBLE_in_double_floating_point_type2575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOUBLE_in_double_floating_point_type2575	= { FOLLOW_DOUBLE_in_double_floating_point_type2575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_numeric_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_numeric_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_numeric_type0	= { FOLLOW_set_in_numeric_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_array_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_array_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_array_type0	= { FOLLOW_set_in_array_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_multiplicitive_advanced_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_multiplicitive_advanced_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_multiplicitive_advanced_type0	= { FOLLOW_set_in_multiplicitive_advanced_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_advanced_numeric_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_advanced_numeric_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_advanced_numeric_type0	= { FOLLOW_set_in_advanced_numeric_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_advanced_array_type0  */
static	ANTLR3_BITWORD FOLLOW_set_in_advanced_array_type0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_advanced_array_type0	= { FOLLOW_set_in_advanced_array_type0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_literal_value0  */
static	ANTLR3_BITWORD FOLLOW_set_in_literal_value0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_literal_value0	= { FOLLOW_set_in_literal_value0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLAGS8_in_flags3097  */
static	ANTLR3_BITWORD FOLLOW_FLAGS8_in_flags3097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLAGS8_in_flags3097	= { FOLLOW_FLAGS8_in_flags3097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLAGS16_in_flags3118  */
static	ANTLR3_BITWORD FOLLOW_FLAGS16_in_flags3118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLAGS16_in_flags3118	= { FOLLOW_FLAGS16_in_flags3118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLAGS32_in_flags3139  */
static	ANTLR3_BITWORD FOLLOW_FLAGS32_in_flags3139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLAGS32_in_flags3139	= { FOLLOW_FLAGS32_in_flags3139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLAGS64_in_flags3160  */
static	ANTLR3_BITWORD FOLLOW_FLAGS64_in_flags3160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLAGS64_in_flags3160	= { FOLLOW_FLAGS64_in_flags3160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_integer0  */
static	ANTLR3_BITWORD FOLLOW_set_in_integer0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_integer0	= { FOLLOW_set_in_integer0_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start protocol
 * ProtoJS.g:82:1: protocol : protoroot -> STRING_LITERAL[\"\\\"use strict\\\"\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] IDENTIFIER[$NameSpace::jsPackageDefinition->chars] protoroot ;
 */
static ProtoJSParser_protocol_return
protocol(pProtoJSParser ctx)
{   
    ProtoJSParser_protocol_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_protoroot_return protoroot1;
    #undef	RETURN_TYPE_protoroot1
    #define	RETURN_TYPE_protoroot1 ProtoJSParser_protoroot_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_protoroot;
    /* Initialize rule variables
     */
    ctx->pProtoJSParser_SymbolsTop = pProtoJSParser_SymbolsPush(ctx);

    root_0 = NULL;


            initSymbolTable(SCOPE_TOP(Symbols),NULL,0);
        
    protoroot1.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_protoroot   = NULL;
    #define CREATE_stream_protoroot  if (stream_protoroot == NULL) {stream_protoroot = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule protoroot"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:87:5: ( protoroot -> STRING_LITERAL[\"\\\"use strict\\\"\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] IDENTIFIER[$NameSpace::jsPackageDefinition->chars] protoroot )
        // ProtoJS.g:87:7: protoroot
        {
            FOLLOWPUSH(FOLLOW_protoroot_in_protocol104);
            protoroot1=protoroot(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprotocolEx;
            }

            CREATE_stream_protoroot; stream_protoroot->add(stream_protoroot, protoroot1.tree, NULL);

             
            /* AST REWRITE
             * elements          : protoroot
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 87:17: -> STRING_LITERAL[\"\\\"use strict\\\"\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] IDENTIFIER[$NameSpace::jsPackageDefinition->chars] protoroot
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	    #if 1 == 2
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, STRING_LITERAL, TOKTEXT("\"use strict\""))
            	    #else
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STRING_LITERAL, (pANTLR3_UINT8)"\"use strict\"")
            	    #endif
            	    );
            	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	    #if 1 == 2
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
            	    #else
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
            	    #endif
            	    );
            	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	    #if 1 == 2
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
            	    #else
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
            	    #endif
            	    );
            	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	    #if 1 == 2
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT(	(SCOPE_TOP(NameSpace))->jsPackageDefinition->chars))
            	    #else
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)	(SCOPE_TOP(NameSpace))->jsPackageDefinition->chars)
            	    #endif
            	    );
            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_protoroot == NULL ? NULL : stream_protoroot->nextTree(stream_protoroot));

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocolEx; /* Prevent compiler warnings */
    ruleprotocolEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_protoroot != NULL) stream_protoroot->free(stream_protoroot);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_SymbolsPop(ctx);

    return retval;
}
/* $ANTLR end protocol */

/** 
 * $ANTLR start protoroot
 * ProtoJS.g:90:1: protoroot : ( pbj_header )? ( importrule | message | service | enum_def | flags_def | option_assignment )* ( package ( importrule | message | service | enum_def | flags_def | option_assignment )* )? ;
 */
static ProtoJSParser_protoroot_return
protoroot(pProtoJSParser ctx)
{   
    ProtoJSParser_protoroot_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_pbj_header_return pbj_header2;
    #undef	RETURN_TYPE_pbj_header2
    #define	RETURN_TYPE_pbj_header2 ProtoJSParser_pbj_header_return

    ProtoJSParser_importrule_return importrule3;
    #undef	RETURN_TYPE_importrule3
    #define	RETURN_TYPE_importrule3 ProtoJSParser_importrule_return

    ProtoJSParser_message_return message4;
    #undef	RETURN_TYPE_message4
    #define	RETURN_TYPE_message4 ProtoJSParser_message_return

    ProtoJSParser_service_return service5;
    #undef	RETURN_TYPE_service5
    #define	RETURN_TYPE_service5 ProtoJSParser_service_return

    ProtoJSParser_enum_def_return enum_def6;
    #undef	RETURN_TYPE_enum_def6
    #define	RETURN_TYPE_enum_def6 ProtoJSParser_enum_def_return

    ProtoJSParser_flags_def_return flags_def7;
    #undef	RETURN_TYPE_flags_def7
    #define	RETURN_TYPE_flags_def7 ProtoJSParser_flags_def_return

    ProtoJSParser_option_assignment_return option_assignment8;
    #undef	RETURN_TYPE_option_assignment8
    #define	RETURN_TYPE_option_assignment8 ProtoJSParser_option_assignment_return

    ProtoJSParser_package_return package9;
    #undef	RETURN_TYPE_package9
    #define	RETURN_TYPE_package9 ProtoJSParser_package_return

    ProtoJSParser_importrule_return importrule10;
    #undef	RETURN_TYPE_importrule10
    #define	RETURN_TYPE_importrule10 ProtoJSParser_importrule_return

    ProtoJSParser_message_return message11;
    #undef	RETURN_TYPE_message11
    #define	RETURN_TYPE_message11 ProtoJSParser_message_return

    ProtoJSParser_service_return service12;
    #undef	RETURN_TYPE_service12
    #define	RETURN_TYPE_service12 ProtoJSParser_service_return

    ProtoJSParser_enum_def_return enum_def13;
    #undef	RETURN_TYPE_enum_def13
    #define	RETURN_TYPE_enum_def13 ProtoJSParser_enum_def_return

    ProtoJSParser_flags_def_return flags_def14;
    #undef	RETURN_TYPE_flags_def14
    #define	RETURN_TYPE_flags_def14 ProtoJSParser_flags_def_return

    ProtoJSParser_option_assignment_return option_assignment15;
    #undef	RETURN_TYPE_option_assignment15
    #define	RETURN_TYPE_option_assignment15 ProtoJSParser_option_assignment_return


    /* Initialize rule variables
     */
    ctx->pProtoJSParser_NameSpaceTop = pProtoJSParser_NameSpacePush(ctx);

    root_0 = NULL;


            initNameSpace(ctx,SCOPE_TOP(NameSpace));
        
    pbj_header2.tree = NULL;

    importrule3.tree = NULL;

    message4.tree = NULL;

    service5.tree = NULL;

    enum_def6.tree = NULL;

    flags_def7.tree = NULL;

    option_assignment8.tree = NULL;

    package9.tree = NULL;

    importrule10.tree = NULL;

    message11.tree = NULL;

    service12.tree = NULL;

    enum_def13.tree = NULL;

    flags_def14.tree = NULL;

    option_assignment15.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:95:2: ( ( pbj_header )? ( importrule | message | service | enum_def | flags_def | option_assignment )* ( package ( importrule | message | service | enum_def | flags_def | option_assignment )* )? )
        // ProtoJS.g:95:4: ( pbj_header )? ( importrule | message | service | enum_def | flags_def | option_assignment )* ( package ( importrule | message | service | enum_def | flags_def | option_assignment )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // ProtoJS.g:95:4: ( pbj_header )?
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                    case STRING_LITERAL:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1) 
                {
            	case 1:
            	    // ProtoJS.g:95:4: pbj_header
            	    {
            	        FOLLOWPUSH(FOLLOW_pbj_header_in_protoroot152);
            	        pbj_header2=pbj_header(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, pbj_header2.tree);

            	    }
            	    break;

                }
            }

            // ProtoJS.g:95:16: ( importrule | message | service | enum_def | flags_def | option_assignment )*

            for (;;)
            {
                int alt2=7;
                switch ( LA(1) ) 
                {
                case IMPORTLITERAL:
                	{
                		alt2=1;
                	}
                    break;
                case MESSAGE:
                case EXTEND:
                	{
                		alt2=2;
                	}
                    break;
                case SERVICE:
                	{
                		alt2=3;
                	}
                    break;
                case ENUM:
                	{
                		alt2=4;
                	}
                    break;
                case FLAGS8:
                case FLAGS16:
                case FLAGS32:
                case FLAGS64:
                	{
                		alt2=5;
                	}
                    break;
                case OPTION_LITERAL:
                	{
                		alt2=6;
                	}
                    break;

                }

                switch (alt2) 
                {
            	case 1:
            	    // ProtoJS.g:95:17: importrule
            	    {
            	        FOLLOWPUSH(FOLLOW_importrule_in_protoroot156);
            	        importrule3=importrule(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, importrule3.tree);

            	    }
            	    break;
            	case 2:
            	    // ProtoJS.g:95:28: message
            	    {
            	        FOLLOWPUSH(FOLLOW_message_in_protoroot158);
            	        message4=message(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, message4.tree);

            	    }
            	    break;
            	case 3:
            	    // ProtoJS.g:95:36: service
            	    {
            	        FOLLOWPUSH(FOLLOW_service_in_protoroot160);
            	        service5=service(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, service5.tree);

            	    }
            	    break;
            	case 4:
            	    // ProtoJS.g:95:44: enum_def
            	    {
            	        FOLLOWPUSH(FOLLOW_enum_def_in_protoroot162);
            	        enum_def6=enum_def(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, enum_def6.tree);

            	    }
            	    break;
            	case 5:
            	    // ProtoJS.g:95:53: flags_def
            	    {
            	        FOLLOWPUSH(FOLLOW_flags_def_in_protoroot164);
            	        flags_def7=flags_def(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, flags_def7.tree);

            	    }
            	    break;
            	case 6:
            	    // ProtoJS.g:95:63: option_assignment
            	    {
            	        FOLLOWPUSH(FOLLOW_option_assignment_in_protoroot166);
            	        option_assignment8=option_assignment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, option_assignment8.tree);

            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


            // ProtoJS.g:95:83: ( package ( importrule | message | service | enum_def | flags_def | option_assignment )* )?
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                    case PACKAGELITERAL:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4) 
                {
            	case 1:
            	    // ProtoJS.g:95:84: package ( importrule | message | service | enum_def | flags_def | option_assignment )*
            	    {
            	        FOLLOWPUSH(FOLLOW_package_in_protoroot171);
            	        package9=package(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleprotorootEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, package9.tree);

            	        // ProtoJS.g:95:92: ( importrule | message | service | enum_def | flags_def | option_assignment )*

            	        for (;;)
            	        {
            	            int alt3=7;
            	            switch ( LA(1) ) 
            	            {
            	            case IMPORTLITERAL:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;
            	            case MESSAGE:
            	            case EXTEND:
            	            	{
            	            		alt3=2;
            	            	}
            	                break;
            	            case SERVICE:
            	            	{
            	            		alt3=3;
            	            	}
            	                break;
            	            case ENUM:
            	            	{
            	            		alt3=4;
            	            	}
            	                break;
            	            case FLAGS8:
            	            case FLAGS16:
            	            case FLAGS32:
            	            case FLAGS64:
            	            	{
            	            		alt3=5;
            	            	}
            	                break;
            	            case OPTION_LITERAL:
            	            	{
            	            		alt3=6;
            	            	}
            	                break;

            	            }

            	            switch (alt3) 
            	            {
            	        	case 1:
            	        	    // ProtoJS.g:95:93: importrule
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_importrule_in_protoroot174);
            	        	        importrule10=importrule(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, importrule10.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // ProtoJS.g:95:104: message
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_message_in_protoroot176);
            	        	        message11=message(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, message11.tree);

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // ProtoJS.g:95:112: service
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_service_in_protoroot178);
            	        	        service12=service(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, service12.tree);

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // ProtoJS.g:95:120: enum_def
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_enum_def_in_protoroot180);
            	        	        enum_def13=enum_def(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, enum_def13.tree);

            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // ProtoJS.g:95:129: flags_def
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_flags_def_in_protoroot182);
            	        	        flags_def14=flags_def(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, flags_def14.tree);

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // ProtoJS.g:95:139: option_assignment
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_option_assignment_in_protoroot184);
            	        	        option_assignment15=option_assignment(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleprotorootEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, option_assignment15.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }
            {

                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotorootEx; /* Prevent compiler warnings */
    ruleprotorootEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_NameSpacePop(ctx);

    return retval;
}
/* $ANTLR end protoroot */

/** 
 * $ANTLR start pbj_header
 * ProtoJS.g:99:1: pbj_header : ( STRING_LITERAL -> IDENTIFIER[$NameSpace::packageDot->chars] IDENTIFIER[\"_PBJ_Internal\"] EQUALS[\"=\"] STRING_LITERAL ITEM_TERMINATOR[\";\"] WS[\"\\n\"] ) ;
 */
static ProtoJSParser_pbj_header_return
pbj_header(pProtoJSParser ctx)
{   
    ProtoJSParser_pbj_header_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    STRING_LITERAL16;

    pANTLR3_BASE_TREE STRING_LITERAL16_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING_LITERAL;

    /* Initialize rule variables
     */


    root_0 = NULL;

    STRING_LITERAL16       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    STRING_LITERAL16_tree   = NULL;

    stream_STRING_LITERAL   = NULL;
    #define CREATE_stream_STRING_LITERAL  if (stream_STRING_LITERAL == NULL) {stream_STRING_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING_LITERAL"); } 

    retval.tree  = NULL;
    {
        // ProtoJS.g:99:12: ( ( STRING_LITERAL -> IDENTIFIER[$NameSpace::packageDot->chars] IDENTIFIER[\"_PBJ_Internal\"] EQUALS[\"=\"] STRING_LITERAL ITEM_TERMINATOR[\";\"] WS[\"\\n\"] ) )
        // ProtoJS.g:99:14: ( STRING_LITERAL -> IDENTIFIER[$NameSpace::packageDot->chars] IDENTIFIER[\"_PBJ_Internal\"] EQUALS[\"=\"] STRING_LITERAL ITEM_TERMINATOR[\";\"] WS[\"\\n\"] )
        {
            // ProtoJS.g:99:14: ( STRING_LITERAL -> IDENTIFIER[$NameSpace::packageDot->chars] IDENTIFIER[\"_PBJ_Internal\"] EQUALS[\"=\"] STRING_LITERAL ITEM_TERMINATOR[\";\"] WS[\"\\n\"] )
            // ProtoJS.g:99:15: STRING_LITERAL
            {
                STRING_LITERAL16 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_pbj_header204); 
                if  (HASEXCEPTION())
                {
                    goto rulepbj_headerEx;
                }
                 
                CREATE_stream_STRING_LITERAL; stream_STRING_LITERAL->add(stream_STRING_LITERAL, STRING_LITERAL16, NULL);


                 
                /* AST REWRITE
                 * elements          : STRING_LITERAL
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 99:30: -> IDENTIFIER[$NameSpace::packageDot->chars] IDENTIFIER[\"_PBJ_Internal\"] EQUALS[\"=\"] STRING_LITERAL ITEM_TERMINATOR[\";\"] WS[\"\\n\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT(	(SCOPE_TOP(NameSpace))->packageDot->chars))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)	(SCOPE_TOP(NameSpace))->packageDot->chars)
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT("_PBJ_Internal"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)"_PBJ_Internal")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, EQUALS, TOKTEXT("="))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EQUALS, (pANTLR3_UINT8)"=")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_STRING_LITERAL == NULL ? NULL : stream_STRING_LITERAL->nextNode(stream_STRING_LITERAL));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            if (strncmp((char*)(STRING_LITERAL16->getText(STRING_LITERAL16))->chars,"\"pbj-0.0.3\"",9)==0&&(STRING_LITERAL16->getText(STRING_LITERAL16))->chars[9]<='9'&&(STRING_LITERAL16->getText(STRING_LITERAL16))->chars[9]>='3') {
                                
                            }else {

                                fprintf(stderr,"error: line %d: pbj version %s not understood--this compiler understands \"pbj-0.0.3\"\n",STRING_LITERAL16->line,(STRING_LITERAL16->getText(STRING_LITERAL16))->chars);  
                            }
                            	(SCOPE_TOP(NameSpace))->isPBJ=1;
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepbj_headerEx; /* Prevent compiler warnings */
    rulepbj_headerEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_STRING_LITERAL != NULL) stream_STRING_LITERAL->free(stream_STRING_LITERAL);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end pbj_header */

/** 
 * $ANTLR start package
 * ProtoJS.g:110:1: package : ( PACKAGELITERAL packagename ITEM_TERMINATOR -> WS[\"\\n\"] ) ;
 */
static ProtoJSParser_package_return
package(pProtoJSParser ctx)
{   
    ProtoJSParser_package_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    PACKAGELITERAL17;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR19;
    ProtoJSParser_packagename_return packagename18;
    #undef	RETURN_TYPE_packagename18
    #define	RETURN_TYPE_packagename18 ProtoJSParser_packagename_return

    pANTLR3_BASE_TREE PACKAGELITERAL17_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR19_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PACKAGELITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_packagename;
    /* Initialize rule variables
     */


    root_0 = NULL;

    PACKAGELITERAL17       = NULL;
    ITEM_TERMINATOR19       = NULL;
    packagename18.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    PACKAGELITERAL17_tree   = NULL;
    ITEM_TERMINATOR19_tree   = NULL;

    stream_PACKAGELITERAL   = NULL;
    #define CREATE_stream_PACKAGELITERAL  if (stream_PACKAGELITERAL == NULL) {stream_PACKAGELITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PACKAGELITERAL"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_packagename   = NULL;
    #define CREATE_stream_packagename  if (stream_packagename == NULL) {stream_packagename = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule packagename"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:112:5: ( ( PACKAGELITERAL packagename ITEM_TERMINATOR -> WS[\"\\n\"] ) )
        // ProtoJS.g:112:7: ( PACKAGELITERAL packagename ITEM_TERMINATOR -> WS[\"\\n\"] )
        {
            // ProtoJS.g:112:7: ( PACKAGELITERAL packagename ITEM_TERMINATOR -> WS[\"\\n\"] )
            // ProtoJS.g:112:9: PACKAGELITERAL packagename ITEM_TERMINATOR
            {
                PACKAGELITERAL17 = (pANTLR3_COMMON_TOKEN) MATCHT(PACKAGELITERAL, &FOLLOW_PACKAGELITERAL_in_package253); 
                if  (HASEXCEPTION())
                {
                    goto rulepackageEx;
                }
                 
                CREATE_stream_PACKAGELITERAL; stream_PACKAGELITERAL->add(stream_PACKAGELITERAL, PACKAGELITERAL17, NULL);

                FOLLOWPUSH(FOLLOW_packagename_in_package255);
                packagename18=packagename(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulepackageEx;
                }

                CREATE_stream_packagename; stream_packagename->add(stream_packagename, packagename18.tree, NULL);
                ITEM_TERMINATOR19 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_package257); 
                if  (HASEXCEPTION())
                {
                    goto rulepackageEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR19, NULL);


                 
                /* AST REWRITE
                 * elements          : 
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 112:52: -> WS[\"\\n\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            jsPackageDefine(	(SCOPE_TOP(NameSpace))->jsPackageDefinition,(STRSTREAM->toStringTT(STRSTREAM, packagename18.start, packagename18.stop)));
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepackageEx; /* Prevent compiler warnings */
    rulepackageEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_PACKAGELITERAL != NULL) stream_PACKAGELITERAL->free(stream_PACKAGELITERAL);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_packagename != NULL) stream_packagename->free(stream_packagename);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end package */

/** 
 * $ANTLR start packagename
 * ProtoJS.g:117:1: packagename : ( QUALIFIEDIDENTIFIER | IDENTIFIER );
 */
static ProtoJSParser_packagename_return
packagename(pProtoJSParser ctx)
{   
    ProtoJSParser_packagename_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    QUALIFIEDIDENTIFIER20;
    pANTLR3_COMMON_TOKEN    IDENTIFIER21;

    pANTLR3_BASE_TREE QUALIFIEDIDENTIFIER20_tree;
    pANTLR3_BASE_TREE IDENTIFIER21_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    QUALIFIEDIDENTIFIER20       = NULL;
    IDENTIFIER21       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    QUALIFIEDIDENTIFIER20_tree   = NULL;
    IDENTIFIER21_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:117:13: ( QUALIFIEDIDENTIFIER | IDENTIFIER )
            
            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) ) 
            {
            case QUALIFIEDIDENTIFIER:
            	{
            		alt5=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt5=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulepackagenameEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // ProtoJS.g:117:15: QUALIFIEDIDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        QUALIFIEDIDENTIFIER20 = (pANTLR3_COMMON_TOKEN) MATCHT(QUALIFIEDIDENTIFIER, &FOLLOW_QUALIFIEDIDENTIFIER_in_packagename282); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepackagenameEx;
        	        }

        	        QUALIFIEDIDENTIFIER20_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, QUALIFIEDIDENTIFIER20));
        	        ADAPTOR->addChild(ADAPTOR, root_0, QUALIFIEDIDENTIFIER20_tree);

        	        {

        	                        definePackage( ctx, (QUALIFIEDIDENTIFIER20->getText(QUALIFIEDIDENTIFIER20)));
        	                
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:121:8: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER21 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_packagename297); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepackagenameEx;
        	        }

        	        IDENTIFIER21_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER21));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER21_tree);

        	        {

        	                        definePackage( ctx, (IDENTIFIER21->getText(IDENTIFIER21)));
        	                
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepackagenameEx; /* Prevent compiler warnings */
    rulepackagenameEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end packagename */

/** 
 * $ANTLR start importrule
 * ProtoJS.g:126:1: importrule : ( IMPORTLITERAL STRING_LITERAL ITEM_TERMINATOR -> COMMENT[\"//\"] IMPORTLITERAL WS[\" \"] STRING_LITERAL ITEM_TERMINATOR WS[\"\\n\"] ) ;
 */
static ProtoJSParser_importrule_return
importrule(pProtoJSParser ctx)
{   
    ProtoJSParser_importrule_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IMPORTLITERAL22;
    pANTLR3_COMMON_TOKEN    STRING_LITERAL23;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR24;

    pANTLR3_BASE_TREE IMPORTLITERAL22_tree;
    pANTLR3_BASE_TREE STRING_LITERAL23_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR24_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IMPORTLITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IMPORTLITERAL22       = NULL;
    STRING_LITERAL23       = NULL;
    ITEM_TERMINATOR24       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IMPORTLITERAL22_tree   = NULL;
    STRING_LITERAL23_tree   = NULL;
    ITEM_TERMINATOR24_tree   = NULL;

    stream_IMPORTLITERAL   = NULL;
    #define CREATE_stream_IMPORTLITERAL  if (stream_IMPORTLITERAL == NULL) {stream_IMPORTLITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IMPORTLITERAL"); } 
    stream_STRING_LITERAL   = NULL;
    #define CREATE_stream_STRING_LITERAL  if (stream_STRING_LITERAL == NULL) {stream_STRING_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING_LITERAL"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 

    retval.tree  = NULL;
    {
        // ProtoJS.g:127:4: ( ( IMPORTLITERAL STRING_LITERAL ITEM_TERMINATOR -> COMMENT[\"//\"] IMPORTLITERAL WS[\" \"] STRING_LITERAL ITEM_TERMINATOR WS[\"\\n\"] ) )
        // ProtoJS.g:127:8: ( IMPORTLITERAL STRING_LITERAL ITEM_TERMINATOR -> COMMENT[\"//\"] IMPORTLITERAL WS[\" \"] STRING_LITERAL ITEM_TERMINATOR WS[\"\\n\"] )
        {
            // ProtoJS.g:127:8: ( IMPORTLITERAL STRING_LITERAL ITEM_TERMINATOR -> COMMENT[\"//\"] IMPORTLITERAL WS[\" \"] STRING_LITERAL ITEM_TERMINATOR WS[\"\\n\"] )
            // ProtoJS.g:127:10: IMPORTLITERAL STRING_LITERAL ITEM_TERMINATOR
            {
                IMPORTLITERAL22 = (pANTLR3_COMMON_TOKEN) MATCHT(IMPORTLITERAL, &FOLLOW_IMPORTLITERAL_in_importrule322); 
                if  (HASEXCEPTION())
                {
                    goto ruleimportruleEx;
                }
                 
                CREATE_stream_IMPORTLITERAL; stream_IMPORTLITERAL->add(stream_IMPORTLITERAL, IMPORTLITERAL22, NULL);

                STRING_LITERAL23 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_importrule324); 
                if  (HASEXCEPTION())
                {
                    goto ruleimportruleEx;
                }
                 
                CREATE_stream_STRING_LITERAL; stream_STRING_LITERAL->add(stream_STRING_LITERAL, STRING_LITERAL23, NULL);

                ITEM_TERMINATOR24 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_importrule326); 
                if  (HASEXCEPTION())
                {
                    goto ruleimportruleEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR24, NULL);


                 
                /* AST REWRITE
                 * elements          : ITEM_TERMINATOR, STRING_LITERAL, IMPORTLITERAL
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 127:55: -> COMMENT[\"//\"] IMPORTLITERAL WS[\" \"] STRING_LITERAL ITEM_TERMINATOR WS[\"\\n\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMENT, TOKTEXT("//"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMENT, (pANTLR3_UINT8)"//")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_IMPORTLITERAL == NULL ? NULL : stream_IMPORTLITERAL->nextNode(stream_IMPORTLITERAL));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_STRING_LITERAL == NULL ? NULL : stream_STRING_LITERAL->nextNode(stream_STRING_LITERAL));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_ITEM_TERMINATOR == NULL ? NULL : stream_ITEM_TERMINATOR->nextNode(stream_ITEM_TERMINATOR));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineImport( ctx, (STRING_LITERAL23->getText(STRING_LITERAL23)) );
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleimportruleEx; /* Prevent compiler warnings */
    ruleimportruleEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_IMPORTLITERAL != NULL) stream_IMPORTLITERAL->free(stream_IMPORTLITERAL);
        if (stream_STRING_LITERAL != NULL) stream_STRING_LITERAL->free(stream_STRING_LITERAL);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end importrule */

/** 
 * $ANTLR start service
 * ProtoJS.g:133:1: service : ( SERVICE IDENTIFIER BLOCK_OPEN ( service_block )* BLOCK_CLOSE ->) ;
 */
static ProtoJSParser_service_return
service(pProtoJSParser ctx)
{   
    ProtoJSParser_service_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SERVICE25;
    pANTLR3_COMMON_TOKEN    IDENTIFIER26;
    pANTLR3_COMMON_TOKEN    BLOCK_OPEN27;
    pANTLR3_COMMON_TOKEN    BLOCK_CLOSE29;
    ProtoJSParser_service_block_return service_block28;
    #undef	RETURN_TYPE_service_block28
    #define	RETURN_TYPE_service_block28 ProtoJSParser_service_block_return

    pANTLR3_BASE_TREE SERVICE25_tree;
    pANTLR3_BASE_TREE IDENTIFIER26_tree;
    pANTLR3_BASE_TREE BLOCK_OPEN27_tree;
    pANTLR3_BASE_TREE BLOCK_CLOSE29_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_OPEN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_CLOSE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SERVICE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_service_block;
    /* Initialize rule variables
     */


    root_0 = NULL;

    SERVICE25       = NULL;
    IDENTIFIER26       = NULL;
    BLOCK_OPEN27       = NULL;
    BLOCK_CLOSE29       = NULL;
    service_block28.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SERVICE25_tree   = NULL;
    IDENTIFIER26_tree   = NULL;
    BLOCK_OPEN27_tree   = NULL;
    BLOCK_CLOSE29_tree   = NULL;

    stream_BLOCK_OPEN   = NULL;
    #define CREATE_stream_BLOCK_OPEN  if (stream_BLOCK_OPEN == NULL) {stream_BLOCK_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_OPEN"); } 
    stream_BLOCK_CLOSE   = NULL;
    #define CREATE_stream_BLOCK_CLOSE  if (stream_BLOCK_CLOSE == NULL) {stream_BLOCK_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_CLOSE"); } 
    stream_SERVICE   = NULL;
    #define CREATE_stream_SERVICE  if (stream_SERVICE == NULL) {stream_SERVICE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SERVICE"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_service_block   = NULL;
    #define CREATE_stream_service_block  if (stream_service_block == NULL) {stream_service_block = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule service_block"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:133:8: ( ( SERVICE IDENTIFIER BLOCK_OPEN ( service_block )* BLOCK_CLOSE ->) )
        // ProtoJS.g:133:10: ( SERVICE IDENTIFIER BLOCK_OPEN ( service_block )* BLOCK_CLOSE ->)
        {
            // ProtoJS.g:133:10: ( SERVICE IDENTIFIER BLOCK_OPEN ( service_block )* BLOCK_CLOSE ->)
            // ProtoJS.g:133:11: SERVICE IDENTIFIER BLOCK_OPEN ( service_block )* BLOCK_CLOSE
            {
                SERVICE25 = (pANTLR3_COMMON_TOKEN) MATCHT(SERVICE, &FOLLOW_SERVICE_in_service365); 
                if  (HASEXCEPTION())
                {
                    goto ruleserviceEx;
                }
                 
                CREATE_stream_SERVICE; stream_SERVICE->add(stream_SERVICE, SERVICE25, NULL);

                IDENTIFIER26 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_service367); 
                if  (HASEXCEPTION())
                {
                    goto ruleserviceEx;
                }
                 
                CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER26, NULL);

                BLOCK_OPEN27 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_OPEN, &FOLLOW_BLOCK_OPEN_in_service369); 
                if  (HASEXCEPTION())
                {
                    goto ruleserviceEx;
                }
                 
                CREATE_stream_BLOCK_OPEN; stream_BLOCK_OPEN->add(stream_BLOCK_OPEN, BLOCK_OPEN27, NULL);


                // ProtoJS.g:133:41: ( service_block )*

                for (;;)
                {
                    int alt6=2;
                    switch ( LA(1) ) 
                    {
                    case RPC:
                    	{
                    		alt6=1;
                    	}
                        break;

                    }

                    switch (alt6) 
                    {
                	case 1:
                	    // ProtoJS.g:133:41: service_block
                	    {
                	        FOLLOWPUSH(FOLLOW_service_block_in_service371);
                	        service_block28=service_block(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleserviceEx;
                	        }

                	        CREATE_stream_service_block; stream_service_block->add(stream_service_block, service_block28.tree, NULL);

                	    }
                	    break;

                	default:
                	    goto loop6;	/* break out of the loop */
                	    break;
                    }
                }
                loop6: ; /* Jump out to here if this rule does not match */

                BLOCK_CLOSE29 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_CLOSE, &FOLLOW_BLOCK_CLOSE_in_service374); 
                if  (HASEXCEPTION())
                {
                    goto ruleserviceEx;
                }
                 
                CREATE_stream_BLOCK_CLOSE; stream_BLOCK_CLOSE->add(stream_BLOCK_CLOSE, BLOCK_CLOSE29, NULL);


                 
                /* AST REWRITE
                 * elements          : 
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 133:68: ->
                	{
                	    root_0 = NULL; /* <-- rewriteEmptyAlt()) */
                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                     fprintf(stderr,"warning: ignoring service %s\n",(IDENTIFIER26->getText(IDENTIFIER26))->chars);
                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleserviceEx; /* Prevent compiler warnings */
    ruleserviceEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_BLOCK_OPEN != NULL) stream_BLOCK_OPEN->free(stream_BLOCK_OPEN);
        if (stream_BLOCK_CLOSE != NULL) stream_BLOCK_CLOSE->free(stream_BLOCK_CLOSE);
        if (stream_SERVICE != NULL) stream_SERVICE->free(stream_SERVICE);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_service_block != NULL) stream_service_block->free(stream_service_block);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end service */

/** 
 * $ANTLR start service_block
 * ProtoJS.g:137:1: service_block : RPC IDENTIFIER PAREN_OPEN ( service_args )? PAREN_CLOSE RETURNS PAREN_OPEN IDENTIFIER PAREN_CLOSE ITEM_TERMINATOR ;
 */
static ProtoJSParser_service_block_return
service_block(pProtoJSParser ctx)
{   
    ProtoJSParser_service_block_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    RPC30;
    pANTLR3_COMMON_TOKEN    IDENTIFIER31;
    pANTLR3_COMMON_TOKEN    PAREN_OPEN32;
    pANTLR3_COMMON_TOKEN    PAREN_CLOSE34;
    pANTLR3_COMMON_TOKEN    RETURNS35;
    pANTLR3_COMMON_TOKEN    PAREN_OPEN36;
    pANTLR3_COMMON_TOKEN    IDENTIFIER37;
    pANTLR3_COMMON_TOKEN    PAREN_CLOSE38;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR39;
    ProtoJSParser_service_args_return service_args33;
    #undef	RETURN_TYPE_service_args33
    #define	RETURN_TYPE_service_args33 ProtoJSParser_service_args_return

    pANTLR3_BASE_TREE RPC30_tree;
    pANTLR3_BASE_TREE IDENTIFIER31_tree;
    pANTLR3_BASE_TREE PAREN_OPEN32_tree;
    pANTLR3_BASE_TREE PAREN_CLOSE34_tree;
    pANTLR3_BASE_TREE RETURNS35_tree;
    pANTLR3_BASE_TREE PAREN_OPEN36_tree;
    pANTLR3_BASE_TREE IDENTIFIER37_tree;
    pANTLR3_BASE_TREE PAREN_CLOSE38_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR39_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    RPC30       = NULL;
    IDENTIFIER31       = NULL;
    PAREN_OPEN32       = NULL;
    PAREN_CLOSE34       = NULL;
    RETURNS35       = NULL;
    PAREN_OPEN36       = NULL;
    IDENTIFIER37       = NULL;
    PAREN_CLOSE38       = NULL;
    ITEM_TERMINATOR39       = NULL;
    service_args33.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    RPC30_tree   = NULL;
    IDENTIFIER31_tree   = NULL;
    PAREN_OPEN32_tree   = NULL;
    PAREN_CLOSE34_tree   = NULL;
    RETURNS35_tree   = NULL;
    PAREN_OPEN36_tree   = NULL;
    IDENTIFIER37_tree   = NULL;
    PAREN_CLOSE38_tree   = NULL;
    ITEM_TERMINATOR39_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:137:15: ( RPC IDENTIFIER PAREN_OPEN ( service_args )? PAREN_CLOSE RETURNS PAREN_OPEN IDENTIFIER PAREN_CLOSE ITEM_TERMINATOR )
        // ProtoJS.g:137:17: RPC IDENTIFIER PAREN_OPEN ( service_args )? PAREN_CLOSE RETURNS PAREN_OPEN IDENTIFIER PAREN_CLOSE ITEM_TERMINATOR
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            RPC30 = (pANTLR3_COMMON_TOKEN) MATCHT(RPC, &FOLLOW_RPC_in_service_block389); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            RPC30_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RPC30));
            ADAPTOR->addChild(ADAPTOR, root_0, RPC30_tree);

            IDENTIFIER31 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_service_block391); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            IDENTIFIER31_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER31));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER31_tree);

            PAREN_OPEN32 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_OPEN, &FOLLOW_PAREN_OPEN_in_service_block393); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            PAREN_OPEN32_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PAREN_OPEN32));
            ADAPTOR->addChild(ADAPTOR, root_0, PAREN_OPEN32_tree);


            // ProtoJS.g:137:43: ( service_args )?
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                    case IDENTIFIER:
                    	{
                    		alt7=1;
                    	}
                        break;
                }

                switch (alt7) 
                {
            	case 1:
            	    // ProtoJS.g:137:43: service_args
            	    {
            	        FOLLOWPUSH(FOLLOW_service_args_in_service_block395);
            	        service_args33=service_args(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleservice_blockEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, service_args33.tree);

            	    }
            	    break;

                }
            }
            PAREN_CLOSE34 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_CLOSE, &FOLLOW_PAREN_CLOSE_in_service_block398); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            PAREN_CLOSE34_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PAREN_CLOSE34));
            ADAPTOR->addChild(ADAPTOR, root_0, PAREN_CLOSE34_tree);

            RETURNS35 = (pANTLR3_COMMON_TOKEN) MATCHT(RETURNS, &FOLLOW_RETURNS_in_service_block400); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            RETURNS35_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RETURNS35));
            ADAPTOR->addChild(ADAPTOR, root_0, RETURNS35_tree);

            PAREN_OPEN36 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_OPEN, &FOLLOW_PAREN_OPEN_in_service_block402); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            PAREN_OPEN36_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PAREN_OPEN36));
            ADAPTOR->addChild(ADAPTOR, root_0, PAREN_OPEN36_tree);

            IDENTIFIER37 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_service_block404); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            IDENTIFIER37_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER37));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER37_tree);

            PAREN_CLOSE38 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_CLOSE, &FOLLOW_PAREN_CLOSE_in_service_block406); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            PAREN_CLOSE38_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PAREN_CLOSE38));
            ADAPTOR->addChild(ADAPTOR, root_0, PAREN_CLOSE38_tree);

            ITEM_TERMINATOR39 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_service_block408); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_blockEx;
            }

            ITEM_TERMINATOR39_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ITEM_TERMINATOR39));
            ADAPTOR->addChild(ADAPTOR, root_0, ITEM_TERMINATOR39_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleservice_blockEx; /* Prevent compiler warnings */
    ruleservice_blockEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end service_block */

/** 
 * $ANTLR start service_args
 * ProtoJS.g:139:1: service_args : IDENTIFIER ( COMMA service_args )? ;
 */
static ProtoJSParser_service_args_return
service_args(pProtoJSParser ctx)
{   
    ProtoJSParser_service_args_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER40;
    pANTLR3_COMMON_TOKEN    COMMA41;
    ProtoJSParser_service_args_return service_args42;
    #undef	RETURN_TYPE_service_args42
    #define	RETURN_TYPE_service_args42 ProtoJSParser_service_args_return

    pANTLR3_BASE_TREE IDENTIFIER40_tree;
    pANTLR3_BASE_TREE COMMA41_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER40       = NULL;
    COMMA41       = NULL;
    service_args42.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER40_tree   = NULL;
    COMMA41_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:139:14: ( IDENTIFIER ( COMMA service_args )? )
        // ProtoJS.g:139:15: IDENTIFIER ( COMMA service_args )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER40 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_service_args416); 
            if  (HASEXCEPTION())
            {
                goto ruleservice_argsEx;
            }

            IDENTIFIER40_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER40));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER40_tree);


            // ProtoJS.g:139:26: ( COMMA service_args )?
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                    case COMMA:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // ProtoJS.g:139:27: COMMA service_args
            	    {
            	        COMMA41 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_service_args419); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleservice_argsEx;
            	        }

            	        COMMA41_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA41));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA41_tree);

            	        FOLLOWPUSH(FOLLOW_service_args_in_service_args421);
            	        service_args42=service_args(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleservice_argsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, service_args42.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleservice_argsEx; /* Prevent compiler warnings */
    ruleservice_argsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end service_args */

/** 
 * $ANTLR start message
 * ProtoJS.g:142:1: message : ( ( message_not_extend message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> message_identifier WS[\" \"] COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] WS[\"\\n\"] ) | ( extend_not_message message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Extend\"] PAREN_OPEN[\"(\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$extend_not_message.text,$message_identifier.text)] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] ) );
 */
static ProtoJSParser_message_return
message(pProtoJSParser ctx)
{   
    ProtoJSParser_message_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BLOCK_OPEN45;
    pANTLR3_COMMON_TOKEN    BLOCK_CLOSE47;
    pANTLR3_COMMON_TOKEN    BLOCK_OPEN50;
    pANTLR3_COMMON_TOKEN    BLOCK_CLOSE52;
    ProtoJSParser_message_not_extend_return message_not_extend43;
    #undef	RETURN_TYPE_message_not_extend43
    #define	RETURN_TYPE_message_not_extend43 ProtoJSParser_message_not_extend_return

    ProtoJSParser_message_identifier_return message_identifier44;
    #undef	RETURN_TYPE_message_identifier44
    #define	RETURN_TYPE_message_identifier44 ProtoJSParser_message_identifier_return

    ProtoJSParser_at_least_one_message_element_return at_least_one_message_element46;
    #undef	RETURN_TYPE_at_least_one_message_element46
    #define	RETURN_TYPE_at_least_one_message_element46 ProtoJSParser_at_least_one_message_element_return

    ProtoJSParser_extend_not_message_return extend_not_message48;
    #undef	RETURN_TYPE_extend_not_message48
    #define	RETURN_TYPE_extend_not_message48 ProtoJSParser_extend_not_message_return

    ProtoJSParser_message_identifier_return message_identifier49;
    #undef	RETURN_TYPE_message_identifier49
    #define	RETURN_TYPE_message_identifier49 ProtoJSParser_message_identifier_return

    ProtoJSParser_at_least_one_message_element_return at_least_one_message_element51;
    #undef	RETURN_TYPE_at_least_one_message_element51
    #define	RETURN_TYPE_at_least_one_message_element51 ProtoJSParser_at_least_one_message_element_return

    pANTLR3_BASE_TREE BLOCK_OPEN45_tree;
    pANTLR3_BASE_TREE BLOCK_CLOSE47_tree;
    pANTLR3_BASE_TREE BLOCK_OPEN50_tree;
    pANTLR3_BASE_TREE BLOCK_CLOSE52_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_OPEN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_CLOSE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_extend_not_message;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_at_least_one_message_element;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_message_not_extend;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_message_identifier;
    /* Initialize rule variables
     */

    ctx->pProtoJSParser_messageTop = pProtoJSParser_messagePush(ctx);
    root_0 = NULL;

    BLOCK_OPEN45       = NULL;
    BLOCK_CLOSE47       = NULL;
    BLOCK_OPEN50       = NULL;
    BLOCK_CLOSE52       = NULL;
    message_not_extend43.tree = NULL;

    message_identifier44.tree = NULL;

    at_least_one_message_element46.tree = NULL;

    extend_not_message48.tree = NULL;

    message_identifier49.tree = NULL;

    at_least_one_message_element51.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    BLOCK_OPEN45_tree   = NULL;
    BLOCK_CLOSE47_tree   = NULL;
    BLOCK_OPEN50_tree   = NULL;
    BLOCK_CLOSE52_tree   = NULL;

    stream_BLOCK_OPEN   = NULL;
    #define CREATE_stream_BLOCK_OPEN  if (stream_BLOCK_OPEN == NULL) {stream_BLOCK_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_OPEN"); } 
    stream_BLOCK_CLOSE   = NULL;
    #define CREATE_stream_BLOCK_CLOSE  if (stream_BLOCK_CLOSE == NULL) {stream_BLOCK_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_CLOSE"); } 
    stream_extend_not_message   = NULL;
    #define CREATE_stream_extend_not_message  if (stream_extend_not_message == NULL) {stream_extend_not_message = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule extend_not_message"); }
    stream_at_least_one_message_element   = NULL;
    #define CREATE_stream_at_least_one_message_element  if (stream_at_least_one_message_element == NULL) {stream_at_least_one_message_element = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule at_least_one_message_element"); }
    stream_message_not_extend   = NULL;
    #define CREATE_stream_message_not_extend  if (stream_message_not_extend == NULL) {stream_message_not_extend = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule message_not_extend"); }
    stream_message_identifier   = NULL;
    #define CREATE_stream_message_identifier  if (stream_message_identifier == NULL) {stream_message_identifier = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule message_identifier"); }

    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:147:5: ( ( message_not_extend message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> message_identifier WS[\" \"] COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] WS[\"\\n\"] ) | ( extend_not_message message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Extend\"] PAREN_OPEN[\"(\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$extend_not_message.text,$message_identifier.text)] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] ) )
            
            ANTLR3_UINT32 alt11;

            alt11=2;

            switch ( LA(1) ) 
            {
            case MESSAGE:
            	{
            		alt11=1;
            	}
                break;
            case EXTEND:
            	{
            		alt11=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto rulemessageEx;
            }

            switch (alt11) 
            {
        	case 1:
        	    // ProtoJS.g:147:9: ( message_not_extend message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> message_identifier WS[\" \"] COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] WS[\"\\n\"] )
        	    {
        	        // ProtoJS.g:147:9: ( message_not_extend message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> message_identifier WS[\" \"] COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] WS[\"\\n\"] )
        	        // ProtoJS.g:147:11: message_not_extend message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE
        	        {
        	            FOLLOWPUSH(FOLLOW_message_not_extend_in_message453);
        	            message_not_extend43=message_not_extend(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }

        	            CREATE_stream_message_not_extend; stream_message_not_extend->add(stream_message_not_extend, message_not_extend43.tree, NULL);
        	            FOLLOWPUSH(FOLLOW_message_identifier_in_message455);
        	            message_identifier44=message_identifier(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }

        	            CREATE_stream_message_identifier; stream_message_identifier->add(stream_message_identifier, message_identifier44.tree, NULL);
        	            BLOCK_OPEN45 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_OPEN, &FOLLOW_BLOCK_OPEN_in_message457); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }
        	             
        	            CREATE_stream_BLOCK_OPEN; stream_BLOCK_OPEN->add(stream_BLOCK_OPEN, BLOCK_OPEN45, NULL);


        	            // ProtoJS.g:147:60: ( at_least_one_message_element )?
        	            {
        	                int alt9=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case MESSAGE:
        	                    case EXTEND:
        	                    case EXTENSIONS:
        	                    case RESERVE:
        	                    case ENUM:
        	                    case ProtoJSOPTIONAL:
        	                    case REQUIRED:
        	                    case REPEATED:
        	                    case FLAGS8:
        	                    case FLAGS16:
        	                    case FLAGS32:
        	                    case FLAGS64:
        	                    	{
        	                    		alt9=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt9) 
        	                {
        	            	case 1:
        	            	    // ProtoJS.g:147:61: at_least_one_message_element
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_at_least_one_message_element_in_message460);
        	            	        at_least_one_message_element46=at_least_one_message_element(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulemessageEx;
        	            	        }

        	            	        CREATE_stream_at_least_one_message_element; stream_at_least_one_message_element->add(stream_at_least_one_message_element, at_least_one_message_element46.tree, NULL);

        	            	    }
        	            	    break;

        	                }
        	            }
        	            BLOCK_CLOSE47 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_CLOSE, &FOLLOW_BLOCK_CLOSE_in_message464); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }
        	             
        	            CREATE_stream_BLOCK_CLOSE; stream_BLOCK_CLOSE->add(stream_BLOCK_CLOSE, BLOCK_CLOSE47, NULL);


        	             
        	            /* AST REWRITE
        	             * elements          : BLOCK_OPEN, message_identifier, message_identifier, BLOCK_CLOSE, at_least_one_message_element, BLOCK_OPEN, at_least_one_message_element, BLOCK_CLOSE
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 148:12: -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"]
        	            	if (ctx->pProtoJSParser_SymbolsStack_limit<=1) 
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT(	(SCOPE_TOP(NameSpace))->packageDot->chars))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)	(SCOPE_TOP(NameSpace))->packageDot->chars)
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_message_identifier == NULL ? NULL : stream_message_identifier->nextTree(stream_message_identifier));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, EQUALS, TOKTEXT("="))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EQUALS, (pANTLR3_UINT8)"=")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Message"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Message")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, message_not_extend43.start, message_not_extend43.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier44.start, message_identifier44.stop)))))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, message_not_extend43.start, message_not_extend43.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier44.start, message_identifier44.stop))))
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_message_element == NULL ? NULL : stream_at_least_one_message_element->nextTree(stream_at_least_one_message_element));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );

        	            	}
        	            	else // 150:19: -> message_identifier WS[\" \"] COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Message\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$message_not_extend.text,$message_identifier.text)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] WS[\"\\n\"]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_message_identifier == NULL ? NULL : stream_message_identifier->nextTree(stream_message_identifier));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Message"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Message")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, message_not_extend43.start, message_not_extend43.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier44.start, message_identifier44.stop)))))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, message_not_extend43.start, message_not_extend43.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier44.start, message_identifier44.stop))))
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_message_element == NULL ? NULL : stream_at_least_one_message_element->nextTree(stream_at_least_one_message_element));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                        if(!	(SCOPE_TOP(message))->isExtension) {
        	                            defineType( ctx, 	(SCOPE_TOP(message))->messageName ,TYPE_ISMESSAGE);
        	                        }
        	                        stringFree(	(SCOPE_TOP(message))->messageName);
        	                    
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:158:13: ( extend_not_message message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Extend\"] PAREN_OPEN[\"(\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$extend_not_message.text,$message_identifier.text)] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] )
        	    {
        	        // ProtoJS.g:158:13: ( extend_not_message message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE -> IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Extend\"] PAREN_OPEN[\"(\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$extend_not_message.text,$message_identifier.text)] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] )
        	        // ProtoJS.g:158:15: extend_not_message message_identifier BLOCK_OPEN ( at_least_one_message_element )? BLOCK_CLOSE
        	        {
        	            FOLLOWPUSH(FOLLOW_extend_not_message_in_message641);
        	            extend_not_message48=extend_not_message(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }

        	            CREATE_stream_extend_not_message; stream_extend_not_message->add(stream_extend_not_message, extend_not_message48.tree, NULL);
        	            FOLLOWPUSH(FOLLOW_message_identifier_in_message643);
        	            message_identifier49=message_identifier(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }

        	            CREATE_stream_message_identifier; stream_message_identifier->add(stream_message_identifier, message_identifier49.tree, NULL);
        	            BLOCK_OPEN50 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_OPEN, &FOLLOW_BLOCK_OPEN_in_message645); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }
        	             
        	            CREATE_stream_BLOCK_OPEN; stream_BLOCK_OPEN->add(stream_BLOCK_OPEN, BLOCK_OPEN50, NULL);


        	            // ProtoJS.g:158:64: ( at_least_one_message_element )?
        	            {
        	                int alt10=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case MESSAGE:
        	                    case EXTEND:
        	                    case EXTENSIONS:
        	                    case RESERVE:
        	                    case ENUM:
        	                    case ProtoJSOPTIONAL:
        	                    case REQUIRED:
        	                    case REPEATED:
        	                    case FLAGS8:
        	                    case FLAGS16:
        	                    case FLAGS32:
        	                    case FLAGS64:
        	                    	{
        	                    		alt10=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt10) 
        	                {
        	            	case 1:
        	            	    // ProtoJS.g:158:65: at_least_one_message_element
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_at_least_one_message_element_in_message648);
        	            	        at_least_one_message_element51=at_least_one_message_element(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulemessageEx;
        	            	        }

        	            	        CREATE_stream_at_least_one_message_element; stream_at_least_one_message_element->add(stream_at_least_one_message_element, at_least_one_message_element51.tree, NULL);

        	            	    }
        	            	    break;

        	                }
        	            }
        	            BLOCK_CLOSE52 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_CLOSE, &FOLLOW_BLOCK_CLOSE_in_message652); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemessageEx;
        	            }
        	             
        	            CREATE_stream_BLOCK_CLOSE; stream_BLOCK_CLOSE->add(stream_BLOCK_CLOSE, BLOCK_CLOSE52, NULL);


        	             
        	            /* AST REWRITE
        	             * elements          : at_least_one_message_element, message_identifier, BLOCK_CLOSE, BLOCK_OPEN
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 159:12: -> IDENTIFIER[$NameSpace::packageDot->chars] message_identifier WS[\" \"] EQUALS[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Extend\"] PAREN_OPEN[\"(\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$extend_not_message.text,$message_identifier.text)] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_message_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT(	(SCOPE_TOP(NameSpace))->packageDot->chars))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)	(SCOPE_TOP(NameSpace))->packageDot->chars)
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_message_identifier == NULL ? NULL : stream_message_identifier->nextTree(stream_message_identifier));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, EQUALS, TOKTEXT("="))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EQUALS, (pANTLR3_UINT8)"=")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Extend"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Extend")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, extend_not_message48.start, extend_not_message48.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier49.start, message_identifier49.stop)))))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, extend_not_message48.start, extend_not_message48.stop)),(STRSTREAM->toStringTT(STRSTREAM, message_identifier49.start, message_identifier49.stop))))
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_message_element == NULL ? NULL : stream_at_least_one_message_element->nextTree(stream_at_least_one_message_element));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                        if(!	(SCOPE_TOP(message))->isExtension) {
        	                            defineType( ctx, 	(SCOPE_TOP(message))->messageName ,TYPE_ISMESSAGE);
        	                        }
        	                        stringFree(	(SCOPE_TOP(message))->messageName);
        	                    
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemessageEx; /* Prevent compiler warnings */
    rulemessageEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_BLOCK_OPEN != NULL) stream_BLOCK_OPEN->free(stream_BLOCK_OPEN);
        if (stream_BLOCK_CLOSE != NULL) stream_BLOCK_CLOSE->free(stream_BLOCK_CLOSE);
        if (stream_extend_not_message != NULL) stream_extend_not_message->free(stream_extend_not_message);
        if (stream_at_least_one_message_element != NULL) stream_at_least_one_message_element->free(stream_at_least_one_message_element);
        if (stream_message_not_extend != NULL) stream_message_not_extend->free(stream_message_not_extend);
        if (stream_message_identifier != NULL) stream_message_identifier->free(stream_message_identifier);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_messagePop(ctx);

    return retval;
}
/* $ANTLR end message */

/** 
 * $ANTLR start message_not_extend
 * ProtoJS.g:168:1: message_not_extend : MESSAGE ;
 */
static ProtoJSParser_message_not_extend_return
message_not_extend(pProtoJSParser ctx)
{   
    ProtoJSParser_message_not_extend_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    MESSAGE53;

    pANTLR3_BASE_TREE MESSAGE53_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    MESSAGE53       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    MESSAGE53_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:168:20: ( MESSAGE )
        // ProtoJS.g:169:9: MESSAGE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            MESSAGE53 = (pANTLR3_COMMON_TOKEN) MATCHT(MESSAGE, &FOLLOW_MESSAGE_in_message_not_extend741); 
            if  (HASEXCEPTION())
            {
                goto rulemessage_not_extendEx;
            }

            MESSAGE53_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MESSAGE53));
            ADAPTOR->addChild(ADAPTOR, root_0, MESSAGE53_tree);

            {
                	(SCOPE_TOP(message))->isExtension=0;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_not_extendEx; /* Prevent compiler warnings */
    rulemessage_not_extendEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end message_not_extend */

/** 
 * $ANTLR start extend_not_message
 * ProtoJS.g:172:1: extend_not_message : EXTEND ;
 */
static ProtoJSParser_extend_not_message_return
extend_not_message(pProtoJSParser ctx)
{   
    ProtoJSParser_extend_not_message_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXTEND54;

    pANTLR3_BASE_TREE EXTEND54_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    EXTEND54       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    EXTEND54_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:172:20: ( EXTEND )
        // ProtoJS.g:173:9: EXTEND
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            EXTEND54 = (pANTLR3_COMMON_TOKEN) MATCHT(EXTEND, &FOLLOW_EXTEND_in_extend_not_message769); 
            if  (HASEXCEPTION())
            {
                goto ruleextend_not_messageEx;
            }

            EXTEND54_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EXTEND54));
            ADAPTOR->addChild(ADAPTOR, root_0, EXTEND54_tree);

            {
                	(SCOPE_TOP(message))->isExtension=1;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextend_not_messageEx; /* Prevent compiler warnings */
    ruleextend_not_messageEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end extend_not_message */

/** 
 * $ANTLR start message_identifier
 * ProtoJS.g:176:1: message_identifier : IDENTIFIER ;
 */
static ProtoJSParser_message_identifier_return
message_identifier(pProtoJSParser ctx)
{   
    ProtoJSParser_message_identifier_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER55;

    pANTLR3_BASE_TREE IDENTIFIER55_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER55       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER55_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:177:5: ( IDENTIFIER )
        // ProtoJS.g:177:7: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER55 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_message_identifier792); 
            if  (HASEXCEPTION())
            {
                goto rulemessage_identifierEx;
            }

            IDENTIFIER55_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER55));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER55_tree);

            {

                        	(SCOPE_TOP(message))->messageName=stringDup((IDENTIFIER55->getText(IDENTIFIER55)));
                        if (	(SCOPE_TOP(message))->isExtension) {
                            defineExtension(ctx, 	(SCOPE_TOP(message))->messageName);
                        }else {
                            defineMessage(ctx, 	(SCOPE_TOP(message))->messageName);
                        }
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_identifierEx; /* Prevent compiler warnings */
    rulemessage_identifierEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end message_identifier */

/** 
 * $ANTLR start at_least_one_message_element
 * ProtoJS.g:188:1: at_least_one_message_element : ( extensions | reservations )* message_element zero_or_more_message_elements ;
 */
static ProtoJSParser_at_least_one_message_element_return
at_least_one_message_element(pProtoJSParser ctx)
{   
    ProtoJSParser_at_least_one_message_element_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_extensions_return extensions56;
    #undef	RETURN_TYPE_extensions56
    #define	RETURN_TYPE_extensions56 ProtoJSParser_extensions_return

    ProtoJSParser_reservations_return reservations57;
    #undef	RETURN_TYPE_reservations57
    #define	RETURN_TYPE_reservations57 ProtoJSParser_reservations_return

    ProtoJSParser_message_element_return message_element58;
    #undef	RETURN_TYPE_message_element58
    #define	RETURN_TYPE_message_element58 ProtoJSParser_message_element_return

    ProtoJSParser_zero_or_more_message_elements_return zero_or_more_message_elements59;
    #undef	RETURN_TYPE_zero_or_more_message_elements59
    #define	RETURN_TYPE_zero_or_more_message_elements59 ProtoJSParser_zero_or_more_message_elements_return


    /* Initialize rule variables
     */
    ctx->pProtoJSParser_SymbolsTop = pProtoJSParser_SymbolsPush(ctx);

    root_0 = NULL;


            initSymbolTable(SCOPE_TOP(Symbols), 	(SCOPE_TOP(message))->messageName, 	(SCOPE_TOP(message))->isExtension);  
        
    extensions56.tree = NULL;

    reservations57.tree = NULL;

    message_element58.tree = NULL;

    zero_or_more_message_elements59.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:194:2: ( ( extensions | reservations )* message_element zero_or_more_message_elements )
        // ProtoJS.g:194:4: ( extensions | reservations )* message_element zero_or_more_message_elements
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // ProtoJS.g:194:4: ( extensions | reservations )*

            for (;;)
            {
                int alt12=3;
                switch ( LA(1) ) 
                {
                case EXTENSIONS:
                	{
                		alt12=1;
                	}
                    break;
                case RESERVE:
                	{
                		alt12=2;
                	}
                    break;

                }

                switch (alt12) 
                {
            	case 1:
            	    // ProtoJS.g:194:5: extensions
            	    {
            	        FOLLOWPUSH(FOLLOW_extensions_in_at_least_one_message_element835);
            	        extensions56=extensions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleat_least_one_message_elementEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensions56.tree);

            	    }
            	    break;
            	case 2:
            	    // ProtoJS.g:194:16: reservations
            	    {
            	        FOLLOWPUSH(FOLLOW_reservations_in_at_least_one_message_element837);
            	        reservations57=reservations(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleat_least_one_message_elementEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, reservations57.tree);

            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_message_element_in_at_least_one_message_element841);
            message_element58=message_element(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_message_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, message_element58.tree);
            FOLLOWPUSH(FOLLOW_zero_or_more_message_elements_in_at_least_one_message_element843);
            zero_or_more_message_elements59=zero_or_more_message_elements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_message_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, zero_or_more_message_elements59.tree);
            {

                        if(	(SCOPE_TOP(message))->isExtension) {
                            defineExtensionEnd(ctx, 	(SCOPE_TOP(message))->messageName);
                        }else {
                            defineMessageEnd(ctx, 	(SCOPE_TOP(message))->messageName);
                        }
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleat_least_one_message_elementEx; /* Prevent compiler warnings */
    ruleat_least_one_message_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_SymbolsPop(ctx);

    return retval;
}
/* $ANTLR end at_least_one_message_element */

/** 
 * $ANTLR start zero_or_more_message_elements
 * ProtoJS.g:203:1: zero_or_more_message_elements : ( newline_message_element | extensions | reservations | option_assignment )* ;
 */
static ProtoJSParser_zero_or_more_message_elements_return
zero_or_more_message_elements(pProtoJSParser ctx)
{   
    ProtoJSParser_zero_or_more_message_elements_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_newline_message_element_return newline_message_element60;
    #undef	RETURN_TYPE_newline_message_element60
    #define	RETURN_TYPE_newline_message_element60 ProtoJSParser_newline_message_element_return

    ProtoJSParser_extensions_return extensions61;
    #undef	RETURN_TYPE_extensions61
    #define	RETURN_TYPE_extensions61 ProtoJSParser_extensions_return

    ProtoJSParser_reservations_return reservations62;
    #undef	RETURN_TYPE_reservations62
    #define	RETURN_TYPE_reservations62 ProtoJSParser_reservations_return

    ProtoJSParser_option_assignment_return option_assignment63;
    #undef	RETURN_TYPE_option_assignment63
    #define	RETURN_TYPE_option_assignment63 ProtoJSParser_option_assignment_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    newline_message_element60.tree = NULL;

    extensions61.tree = NULL;

    reservations62.tree = NULL;

    option_assignment63.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:203:31: ( ( newline_message_element | extensions | reservations | option_assignment )* )
        // ProtoJS.g:203:33: ( newline_message_element | extensions | reservations | option_assignment )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // ProtoJS.g:203:33: ( newline_message_element | extensions | reservations | option_assignment )*

            for (;;)
            {
                int alt13=5;
                switch ( LA(1) ) 
                {
                case MESSAGE:
                case EXTEND:
                case ENUM:
                case ProtoJSOPTIONAL:
                case REQUIRED:
                case REPEATED:
                case FLAGS8:
                case FLAGS16:
                case FLAGS32:
                case FLAGS64:
                	{
                		alt13=1;
                	}
                    break;
                case EXTENSIONS:
                	{
                		alt13=2;
                	}
                    break;
                case RESERVE:
                	{
                		alt13=3;
                	}
                    break;
                case OPTION_LITERAL:
                	{
                		alt13=4;
                	}
                    break;

                }

                switch (alt13) 
                {
            	case 1:
            	    // ProtoJS.g:203:34: newline_message_element
            	    {
            	        FOLLOWPUSH(FOLLOW_newline_message_element_in_zero_or_more_message_elements862);
            	        newline_message_element60=newline_message_element(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezero_or_more_message_elementsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, newline_message_element60.tree);

            	    }
            	    break;
            	case 2:
            	    // ProtoJS.g:203:58: extensions
            	    {
            	        FOLLOWPUSH(FOLLOW_extensions_in_zero_or_more_message_elements864);
            	        extensions61=extensions(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezero_or_more_message_elementsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensions61.tree);

            	    }
            	    break;
            	case 3:
            	    // ProtoJS.g:203:69: reservations
            	    {
            	        FOLLOWPUSH(FOLLOW_reservations_in_zero_or_more_message_elements866);
            	        reservations62=reservations(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezero_or_more_message_elementsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, reservations62.tree);

            	    }
            	    break;
            	case 4:
            	    // ProtoJS.g:203:82: option_assignment
            	    {
            	        FOLLOWPUSH(FOLLOW_option_assignment_in_zero_or_more_message_elements868);
            	        option_assignment63=option_assignment(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezero_or_more_message_elementsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, option_assignment63.tree);

            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulezero_or_more_message_elementsEx; /* Prevent compiler warnings */
    rulezero_or_more_message_elementsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end zero_or_more_message_elements */

/** 
 * $ANTLR start newline_message_element
 * ProtoJS.g:206:1: newline_message_element : ( ( field -> COMMA[\",\"] WS[\"\\n\"] field ) | ( message -> COMMA[\",\"] WS[\"\\n\"] message ) | ( enum_def -> COMMA[\",\"] WS[\"\\n\"] enum_def ) | ( flags_def -> COMMA[\",\"] WS[\"\\n\"] flags_def ) );
 */
static ProtoJSParser_newline_message_element_return
newline_message_element(pProtoJSParser ctx)
{   
    ProtoJSParser_newline_message_element_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_field_return field64;
    #undef	RETURN_TYPE_field64
    #define	RETURN_TYPE_field64 ProtoJSParser_field_return

    ProtoJSParser_message_return message65;
    #undef	RETURN_TYPE_message65
    #define	RETURN_TYPE_message65 ProtoJSParser_message_return

    ProtoJSParser_enum_def_return enum_def66;
    #undef	RETURN_TYPE_enum_def66
    #define	RETURN_TYPE_enum_def66 ProtoJSParser_enum_def_return

    ProtoJSParser_flags_def_return flags_def67;
    #undef	RETURN_TYPE_flags_def67
    #define	RETURN_TYPE_flags_def67 ProtoJSParser_flags_def_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_message;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_field;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_enum_def;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_flags_def;
    /* Initialize rule variables
     */


    root_0 = NULL;

    field64.tree = NULL;

    message65.tree = NULL;

    enum_def66.tree = NULL;

    flags_def67.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_message   = NULL;
    #define CREATE_stream_message  if (stream_message == NULL) {stream_message = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule message"); }
    stream_field   = NULL;
    #define CREATE_stream_field  if (stream_field == NULL) {stream_field = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule field"); }
    stream_enum_def   = NULL;
    #define CREATE_stream_enum_def  if (stream_enum_def == NULL) {stream_enum_def = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule enum_def"); }
    stream_flags_def   = NULL;
    #define CREATE_stream_flags_def  if (stream_flags_def == NULL) {stream_flags_def = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule flags_def"); }

    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:207:2: ( ( field -> COMMA[\",\"] WS[\"\\n\"] field ) | ( message -> COMMA[\",\"] WS[\"\\n\"] message ) | ( enum_def -> COMMA[\",\"] WS[\"\\n\"] enum_def ) | ( flags_def -> COMMA[\",\"] WS[\"\\n\"] flags_def ) )
            
            ANTLR3_UINT32 alt14;

            alt14=4;

            switch ( LA(1) ) 
            {
            case ProtoJSOPTIONAL:
            case REQUIRED:
            case REPEATED:
            	{
            		alt14=1;
            	}
                break;
            case MESSAGE:
            case EXTEND:
            	{
            		alt14=2;
            	}
                break;
            case ENUM:
            	{
            		alt14=3;
            	}
                break;
            case FLAGS8:
            case FLAGS16:
            case FLAGS32:
            case FLAGS64:
            	{
            		alt14=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto rulenewline_message_elementEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // ProtoJS.g:207:4: ( field -> COMMA[\",\"] WS[\"\\n\"] field )
        	    {
        	        // ProtoJS.g:207:4: ( field -> COMMA[\",\"] WS[\"\\n\"] field )
        	        // ProtoJS.g:207:5: field
        	        {
        	            FOLLOWPUSH(FOLLOW_field_in_newline_message_element881);
        	            field64=field(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulenewline_message_elementEx;
        	            }

        	            CREATE_stream_field; stream_field->add(stream_field, field64.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : field
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 207:11: -> COMMA[\",\"] WS[\"\\n\"] field
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_field == NULL ? NULL : stream_field->nextTree(stream_field));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }


        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:208:4: ( message -> COMMA[\",\"] WS[\"\\n\"] message )
        	    {
        	        // ProtoJS.g:208:4: ( message -> COMMA[\",\"] WS[\"\\n\"] message )
        	        // ProtoJS.g:208:5: message
        	        {
        	            FOLLOWPUSH(FOLLOW_message_in_newline_message_element898);
        	            message65=message(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulenewline_message_elementEx;
        	            }

        	            CREATE_stream_message; stream_message->add(stream_message, message65.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : message
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 208:13: -> COMMA[\",\"] WS[\"\\n\"] message
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_message == NULL ? NULL : stream_message->nextTree(stream_message));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }


        	    }
        	    break;
        	case 3:
        	    // ProtoJS.g:209:4: ( enum_def -> COMMA[\",\"] WS[\"\\n\"] enum_def )
        	    {
        	        // ProtoJS.g:209:4: ( enum_def -> COMMA[\",\"] WS[\"\\n\"] enum_def )
        	        // ProtoJS.g:209:5: enum_def
        	        {
        	            FOLLOWPUSH(FOLLOW_enum_def_in_newline_message_element915);
        	            enum_def66=enum_def(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulenewline_message_elementEx;
        	            }

        	            CREATE_stream_enum_def; stream_enum_def->add(stream_enum_def, enum_def66.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : enum_def
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 209:14: -> COMMA[\",\"] WS[\"\\n\"] enum_def
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_enum_def == NULL ? NULL : stream_enum_def->nextTree(stream_enum_def));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }


        	    }
        	    break;
        	case 4:
        	    // ProtoJS.g:210:4: ( flags_def -> COMMA[\",\"] WS[\"\\n\"] flags_def )
        	    {
        	        // ProtoJS.g:210:4: ( flags_def -> COMMA[\",\"] WS[\"\\n\"] flags_def )
        	        // ProtoJS.g:210:5: flags_def
        	        {
        	            FOLLOWPUSH(FOLLOW_flags_def_in_newline_message_element932);
        	            flags_def67=flags_def(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulenewline_message_elementEx;
        	            }

        	            CREATE_stream_flags_def; stream_flags_def->add(stream_flags_def, flags_def67.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : flags_def
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 210:15: -> COMMA[\",\"] WS[\"\\n\"] flags_def
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_flags_def == NULL ? NULL : stream_flags_def->nextTree(stream_flags_def));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenewline_message_elementEx; /* Prevent compiler warnings */
    rulenewline_message_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_message != NULL) stream_message->free(stream_message);
        if (stream_field != NULL) stream_field->free(stream_field);
        if (stream_enum_def != NULL) stream_enum_def->free(stream_enum_def);
        if (stream_flags_def != NULL) stream_flags_def->free(stream_flags_def);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end newline_message_element */

/** 
 * $ANTLR start message_element
 * ProtoJS.g:213:1: message_element : ( field | message | enum_def | flags_def );
 */
static ProtoJSParser_message_element_return
message_element(pProtoJSParser ctx)
{   
    ProtoJSParser_message_element_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_field_return field68;
    #undef	RETURN_TYPE_field68
    #define	RETURN_TYPE_field68 ProtoJSParser_field_return

    ProtoJSParser_message_return message69;
    #undef	RETURN_TYPE_message69
    #define	RETURN_TYPE_message69 ProtoJSParser_message_return

    ProtoJSParser_enum_def_return enum_def70;
    #undef	RETURN_TYPE_enum_def70
    #define	RETURN_TYPE_enum_def70 ProtoJSParser_enum_def_return

    ProtoJSParser_flags_def_return flags_def71;
    #undef	RETURN_TYPE_flags_def71
    #define	RETURN_TYPE_flags_def71 ProtoJSParser_flags_def_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    field68.tree = NULL;

    message69.tree = NULL;

    enum_def70.tree = NULL;

    flags_def71.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:214:2: ( field | message | enum_def | flags_def )
            
            ANTLR3_UINT32 alt15;

            alt15=4;

            switch ( LA(1) ) 
            {
            case ProtoJSOPTIONAL:
            case REQUIRED:
            case REPEATED:
            	{
            		alt15=1;
            	}
                break;
            case MESSAGE:
            case EXTEND:
            	{
            		alt15=2;
            	}
                break;
            case ENUM:
            	{
            		alt15=3;
            	}
                break;
            case FLAGS8:
            case FLAGS16:
            case FLAGS32:
            case FLAGS64:
            	{
            		alt15=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto rulemessage_elementEx;
            }

            switch (alt15) 
            {
        	case 1:
        	    // ProtoJS.g:214:4: field
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_field_in_message_element957);
        	        field68=field(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_elementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, field68.tree);

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:215:4: message
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_message_in_message_element962);
        	        message69=message(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_elementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, message69.tree);

        	    }
        	    break;
        	case 3:
        	    // ProtoJS.g:216:4: enum_def
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_enum_def_in_message_element967);
        	        enum_def70=enum_def(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_elementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, enum_def70.tree);

        	    }
        	    break;
        	case 4:
        	    // ProtoJS.g:217:4: flags_def
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_flags_def_in_message_element972);
        	        flags_def71=flags_def(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_elementEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, flags_def71.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_elementEx; /* Prevent compiler warnings */
    rulemessage_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end message_element */

/** 
 * $ANTLR start extensions
 * ProtoJS.g:220:1: extensions : ( EXTENSIONS integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] ) ;
 */
static ProtoJSParser_extensions_return
extensions(pProtoJSParser ctx)
{   
    ProtoJSParser_extensions_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EXTENSIONS72;
    pANTLR3_COMMON_TOKEN    TO74;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR76;
    ProtoJSParser_integer_return integer73;
    #undef	RETURN_TYPE_integer73
    #define	RETURN_TYPE_integer73 ProtoJSParser_integer_return

    ProtoJSParser_integer_inclusive_return integer_inclusive75;
    #undef	RETURN_TYPE_integer_inclusive75
    #define	RETURN_TYPE_integer_inclusive75 ProtoJSParser_integer_inclusive_return

    pANTLR3_BASE_TREE EXTENSIONS72_tree;
    pANTLR3_BASE_TREE TO74_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR76_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EXTENSIONS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_TO;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer_inclusive;
    /* Initialize rule variables
     */


    root_0 = NULL;

    EXTENSIONS72       = NULL;
    TO74       = NULL;
    ITEM_TERMINATOR76       = NULL;
    integer73.tree = NULL;

    integer_inclusive75.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    EXTENSIONS72_tree   = NULL;
    TO74_tree   = NULL;
    ITEM_TERMINATOR76_tree   = NULL;

    stream_EXTENSIONS   = NULL;
    #define CREATE_stream_EXTENSIONS  if (stream_EXTENSIONS == NULL) {stream_EXTENSIONS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EXTENSIONS"); } 
    stream_TO   = NULL;
    #define CREATE_stream_TO  if (stream_TO == NULL) {stream_TO = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token TO"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_integer   = NULL;
    #define CREATE_stream_integer  if (stream_integer == NULL) {stream_integer = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer"); }
    stream_integer_inclusive   = NULL;
    #define CREATE_stream_integer_inclusive  if (stream_integer_inclusive == NULL) {stream_integer_inclusive = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer_inclusive"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:221:9: ( ( EXTENSIONS integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] ) )
        // ProtoJS.g:222:9: ( EXTENSIONS integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] )
        {
            // ProtoJS.g:222:9: ( EXTENSIONS integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] )
            // ProtoJS.g:222:11: EXTENSIONS integer TO integer_inclusive ITEM_TERMINATOR
            {
                EXTENSIONS72 = (pANTLR3_COMMON_TOKEN) MATCHT(EXTENSIONS, &FOLLOW_EXTENSIONS_in_extensions1001); 
                if  (HASEXCEPTION())
                {
                    goto ruleextensionsEx;
                }
                 
                CREATE_stream_EXTENSIONS; stream_EXTENSIONS->add(stream_EXTENSIONS, EXTENSIONS72, NULL);

                FOLLOWPUSH(FOLLOW_integer_in_extensions1003);
                integer73=integer(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleextensionsEx;
                }

                CREATE_stream_integer; stream_integer->add(stream_integer, integer73.tree, NULL);
                TO74 = (pANTLR3_COMMON_TOKEN) MATCHT(TO, &FOLLOW_TO_in_extensions1005); 
                if  (HASEXCEPTION())
                {
                    goto ruleextensionsEx;
                }
                 
                CREATE_stream_TO; stream_TO->add(stream_TO, TO74, NULL);

                FOLLOWPUSH(FOLLOW_integer_inclusive_in_extensions1007);
                integer_inclusive75=integer_inclusive(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleextensionsEx;
                }

                CREATE_stream_integer_inclusive; stream_integer_inclusive->add(stream_integer_inclusive, integer_inclusive75.tree, NULL);
                ITEM_TERMINATOR76 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_extensions1009); 
                if  (HASEXCEPTION())
                {
                    goto ruleextensionsEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR76, NULL);


                 
                /* AST REWRITE
                 * elements          : 
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 222:67: -> WS[\"\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineExtensionRange(ctx, (STRSTREAM->toStringTT(STRSTREAM, integer73.start, integer73.stop)), (STRSTREAM->toStringTT(STRSTREAM, integer_inclusive75.start, integer_inclusive75.stop)));
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextensionsEx; /* Prevent compiler warnings */
    ruleextensionsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EXTENSIONS != NULL) stream_EXTENSIONS->free(stream_EXTENSIONS);
        if (stream_TO != NULL) stream_TO->free(stream_TO);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_integer != NULL) stream_integer->free(stream_integer);
        if (stream_integer_inclusive != NULL) stream_integer_inclusive->free(stream_integer_inclusive);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end extensions */

/** 
 * $ANTLR start reservations
 * ProtoJS.g:228:1: reservations : ( RESERVE integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] ) ;
 */
static ProtoJSParser_reservations_return
reservations(pProtoJSParser ctx)
{   
    ProtoJSParser_reservations_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    RESERVE77;
    pANTLR3_COMMON_TOKEN    TO79;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR81;
    ProtoJSParser_integer_return integer78;
    #undef	RETURN_TYPE_integer78
    #define	RETURN_TYPE_integer78 ProtoJSParser_integer_return

    ProtoJSParser_integer_inclusive_return integer_inclusive80;
    #undef	RETURN_TYPE_integer_inclusive80
    #define	RETURN_TYPE_integer_inclusive80 ProtoJSParser_integer_inclusive_return

    pANTLR3_BASE_TREE RESERVE77_tree;
    pANTLR3_BASE_TREE TO79_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR81_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RESERVE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_TO;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer_inclusive;
    /* Initialize rule variables
     */


    root_0 = NULL;

    RESERVE77       = NULL;
    TO79       = NULL;
    ITEM_TERMINATOR81       = NULL;
    integer78.tree = NULL;

    integer_inclusive80.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    RESERVE77_tree   = NULL;
    TO79_tree   = NULL;
    ITEM_TERMINATOR81_tree   = NULL;

    stream_RESERVE   = NULL;
    #define CREATE_stream_RESERVE  if (stream_RESERVE == NULL) {stream_RESERVE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RESERVE"); } 
    stream_TO   = NULL;
    #define CREATE_stream_TO  if (stream_TO == NULL) {stream_TO = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token TO"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_integer   = NULL;
    #define CREATE_stream_integer  if (stream_integer == NULL) {stream_integer = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer"); }
    stream_integer_inclusive   = NULL;
    #define CREATE_stream_integer_inclusive  if (stream_integer_inclusive == NULL) {stream_integer_inclusive = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer_inclusive"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:228:14: ( ( RESERVE integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] ) )
        // ProtoJS.g:228:16: ( RESERVE integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] )
        {
            // ProtoJS.g:228:16: ( RESERVE integer TO integer_inclusive ITEM_TERMINATOR -> WS[\"\"] )
            // ProtoJS.g:228:17: RESERVE integer TO integer_inclusive ITEM_TERMINATOR
            {
                RESERVE77 = (pANTLR3_COMMON_TOKEN) MATCHT(RESERVE, &FOLLOW_RESERVE_in_reservations1045); 
                if  (HASEXCEPTION())
                {
                    goto rulereservationsEx;
                }
                 
                CREATE_stream_RESERVE; stream_RESERVE->add(stream_RESERVE, RESERVE77, NULL);

                FOLLOWPUSH(FOLLOW_integer_in_reservations1047);
                integer78=integer(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulereservationsEx;
                }

                CREATE_stream_integer; stream_integer->add(stream_integer, integer78.tree, NULL);
                TO79 = (pANTLR3_COMMON_TOKEN) MATCHT(TO, &FOLLOW_TO_in_reservations1049); 
                if  (HASEXCEPTION())
                {
                    goto rulereservationsEx;
                }
                 
                CREATE_stream_TO; stream_TO->add(stream_TO, TO79, NULL);

                FOLLOWPUSH(FOLLOW_integer_inclusive_in_reservations1051);
                integer_inclusive80=integer_inclusive(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulereservationsEx;
                }

                CREATE_stream_integer_inclusive; stream_integer_inclusive->add(stream_integer_inclusive, integer_inclusive80.tree, NULL);
                ITEM_TERMINATOR81 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_reservations1053); 
                if  (HASEXCEPTION())
                {
                    goto rulereservationsEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR81, NULL);


                 
                /* AST REWRITE
                 * elements          : 
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 228:70: -> WS[\"\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineReservedRange(ctx, (STRSTREAM->toStringTT(STRSTREAM, integer78.start, integer78.stop)), (STRSTREAM->toStringTT(STRSTREAM, integer_inclusive80.start, integer_inclusive80.stop)));
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereservationsEx; /* Prevent compiler warnings */
    rulereservationsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_RESERVE != NULL) stream_RESERVE->free(stream_RESERVE);
        if (stream_TO != NULL) stream_TO->free(stream_TO);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_integer != NULL) stream_integer->free(stream_integer);
        if (stream_integer_inclusive != NULL) stream_integer_inclusive->free(stream_integer_inclusive);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end reservations */

/** 
 * $ANTLR start integer_inclusive
 * ProtoJS.g:234:1: integer_inclusive : integer ;
 */
static ProtoJSParser_integer_inclusive_return
integer_inclusive(pProtoJSParser ctx)
{   
    ProtoJSParser_integer_inclusive_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_integer_return integer82;
    #undef	RETURN_TYPE_integer82
    #define	RETURN_TYPE_integer82 ProtoJSParser_integer_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    integer82.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:234:19: ( integer )
        // ProtoJS.g:234:21: integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_integer_in_integer_inclusive1086);
            integer82=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinteger_inclusiveEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, integer82.tree);
            {

                            
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleinteger_inclusiveEx; /* Prevent compiler warnings */
    ruleinteger_inclusiveEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end integer_inclusive */

/** 
 * $ANTLR start enum_def
 * ProtoJS.g:240:1: enum_def : ( ENUM enum_identifier BLOCK_OPEN at_least_one_enum_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] enum_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element WS[\"\\t\"] BLOCK_CLOSE PAREN_CLOSE[\")\"] ) ;
 */
static ProtoJSParser_enum_def_return
enum_def(pProtoJSParser ctx)
{   
    ProtoJSParser_enum_def_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ENUM83;
    pANTLR3_COMMON_TOKEN    BLOCK_OPEN85;
    pANTLR3_COMMON_TOKEN    BLOCK_CLOSE87;
    ProtoJSParser_enum_identifier_return enum_identifier84;
    #undef	RETURN_TYPE_enum_identifier84
    #define	RETURN_TYPE_enum_identifier84 ProtoJSParser_enum_identifier_return

    ProtoJSParser_at_least_one_enum_element_return at_least_one_enum_element86;
    #undef	RETURN_TYPE_at_least_one_enum_element86
    #define	RETURN_TYPE_at_least_one_enum_element86 ProtoJSParser_at_least_one_enum_element_return

    pANTLR3_BASE_TREE ENUM83_tree;
    pANTLR3_BASE_TREE BLOCK_OPEN85_tree;
    pANTLR3_BASE_TREE BLOCK_CLOSE87_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_OPEN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_CLOSE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ENUM;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_at_least_one_enum_element;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_enum_identifier;
    /* Initialize rule variables
     */

    ctx->pProtoJSParser_enum_defTop = pProtoJSParser_enum_defPush(ctx);
    root_0 = NULL;


            	(SCOPE_TOP(enum_def))->enumList=antlr3ListNew(1);
        
    ENUM83       = NULL;
    BLOCK_OPEN85       = NULL;
    BLOCK_CLOSE87       = NULL;
    enum_identifier84.tree = NULL;

    at_least_one_enum_element86.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    ENUM83_tree   = NULL;
    BLOCK_OPEN85_tree   = NULL;
    BLOCK_CLOSE87_tree   = NULL;

    stream_BLOCK_OPEN   = NULL;
    #define CREATE_stream_BLOCK_OPEN  if (stream_BLOCK_OPEN == NULL) {stream_BLOCK_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_OPEN"); } 
    stream_BLOCK_CLOSE   = NULL;
    #define CREATE_stream_BLOCK_CLOSE  if (stream_BLOCK_CLOSE == NULL) {stream_BLOCK_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_CLOSE"); } 
    stream_ENUM   = NULL;
    #define CREATE_stream_ENUM  if (stream_ENUM == NULL) {stream_ENUM = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ENUM"); } 
    stream_at_least_one_enum_element   = NULL;
    #define CREATE_stream_at_least_one_enum_element  if (stream_at_least_one_enum_element == NULL) {stream_at_least_one_enum_element = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule at_least_one_enum_element"); }
    stream_enum_identifier   = NULL;
    #define CREATE_stream_enum_identifier  if (stream_enum_identifier == NULL) {stream_enum_identifier = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule enum_identifier"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:248:2: ( ( ENUM enum_identifier BLOCK_OPEN at_least_one_enum_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] enum_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element WS[\"\\t\"] BLOCK_CLOSE PAREN_CLOSE[\")\"] ) )
        // ProtoJS.g:248:4: ( ENUM enum_identifier BLOCK_OPEN at_least_one_enum_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] enum_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element WS[\"\\t\"] BLOCK_CLOSE PAREN_CLOSE[\")\"] )
        {
            // ProtoJS.g:248:4: ( ENUM enum_identifier BLOCK_OPEN at_least_one_enum_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] enum_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element WS[\"\\t\"] BLOCK_CLOSE PAREN_CLOSE[\")\"] )
            // ProtoJS.g:248:6: ENUM enum_identifier BLOCK_OPEN at_least_one_enum_element BLOCK_CLOSE
            {
                ENUM83 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUM, &FOLLOW_ENUM_in_enum_def1134); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_defEx;
                }
                 
                CREATE_stream_ENUM; stream_ENUM->add(stream_ENUM, ENUM83, NULL);

                FOLLOWPUSH(FOLLOW_enum_identifier_in_enum_def1136);
                enum_identifier84=enum_identifier(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleenum_defEx;
                }

                CREATE_stream_enum_identifier; stream_enum_identifier->add(stream_enum_identifier, enum_identifier84.tree, NULL);
                BLOCK_OPEN85 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_OPEN, &FOLLOW_BLOCK_OPEN_in_enum_def1138); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_defEx;
                }
                 
                CREATE_stream_BLOCK_OPEN; stream_BLOCK_OPEN->add(stream_BLOCK_OPEN, BLOCK_OPEN85, NULL);

                FOLLOWPUSH(FOLLOW_at_least_one_enum_element_in_enum_def1140);
                at_least_one_enum_element86=at_least_one_enum_element(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleenum_defEx;
                }

                CREATE_stream_at_least_one_enum_element; stream_at_least_one_enum_element->add(stream_at_least_one_enum_element, at_least_one_enum_element86.tree, NULL);
                BLOCK_CLOSE87 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_CLOSE, &FOLLOW_BLOCK_CLOSE_in_enum_def1142); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_defEx;
                }
                 
                CREATE_stream_BLOCK_CLOSE; stream_BLOCK_CLOSE->add(stream_BLOCK_CLOSE, BLOCK_CLOSE87, NULL);


                 
                /* AST REWRITE
                 * elements          : BLOCK_CLOSE, enum_identifier, at_least_one_enum_element, BLOCK_OPEN, BLOCK_CLOSE, BLOCK_OPEN, at_least_one_enum_element
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 249:12: -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"]
                	if (ctx->pProtoJSParser_SymbolsStack_limit<=1) 
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT("="))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)"=")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Enum"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Enum")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_enum_element == NULL ? NULL : stream_at_least_one_enum_element->nextTree(stream_at_least_one_enum_element));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );

                	}
                	else // 251:15: -> WS[\"\\t\"] enum_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Enum\"] PAREN_OPEN[\"(\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$ENUM.text,$enum_def::enumName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_enum_element WS[\"\\t\"] BLOCK_CLOSE PAREN_CLOSE[\")\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_enum_identifier == NULL ? NULL : stream_enum_identifier->nextTree(stream_enum_identifier));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Enum"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Enum")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(ENUM83->getText(ENUM83)),	(SCOPE_TOP(enum_def))->enumName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_enum_element == NULL ? NULL : stream_at_least_one_enum_element->nextTree(stream_at_least_one_enum_element));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineEnum( ctx, 	(SCOPE_TOP(enum_def))->enumName, 	(SCOPE_TOP(enum_def))->enumList);
                            	(SCOPE_TOP(enum_def))->enumList->free(	(SCOPE_TOP(enum_def))->enumList);
                            stringFree(	(SCOPE_TOP(enum_def))->enumName);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenum_defEx; /* Prevent compiler warnings */
    ruleenum_defEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_BLOCK_OPEN != NULL) stream_BLOCK_OPEN->free(stream_BLOCK_OPEN);
        if (stream_BLOCK_CLOSE != NULL) stream_BLOCK_CLOSE->free(stream_BLOCK_CLOSE);
        if (stream_ENUM != NULL) stream_ENUM->free(stream_ENUM);
        if (stream_at_least_one_enum_element != NULL) stream_at_least_one_enum_element->free(stream_at_least_one_enum_element);
        if (stream_enum_identifier != NULL) stream_enum_identifier->free(stream_enum_identifier);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_enum_defPop(ctx);

    return retval;
}
/* $ANTLR end enum_def */

/** 
 * $ANTLR start at_least_one_enum_element
 * ProtoJS.g:258:1: at_least_one_enum_element : enum_element zero_or_more_enum_elements ;
 */
static ProtoJSParser_at_least_one_enum_element_return
at_least_one_enum_element(pProtoJSParser ctx)
{   
    ProtoJSParser_at_least_one_enum_element_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_enum_element_return enum_element88;
    #undef	RETURN_TYPE_enum_element88
    #define	RETURN_TYPE_enum_element88 ProtoJSParser_enum_element_return

    ProtoJSParser_zero_or_more_enum_elements_return zero_or_more_enum_elements89;
    #undef	RETURN_TYPE_zero_or_more_enum_elements89
    #define	RETURN_TYPE_zero_or_more_enum_elements89 ProtoJSParser_zero_or_more_enum_elements_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    enum_element88.tree = NULL;

    zero_or_more_enum_elements89.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:258:27: ( enum_element zero_or_more_enum_elements )
        // ProtoJS.g:258:29: enum_element zero_or_more_enum_elements
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_enum_element_in_at_least_one_enum_element1297);
            enum_element88=enum_element(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_enum_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, enum_element88.tree);
            FOLLOWPUSH(FOLLOW_zero_or_more_enum_elements_in_at_least_one_enum_element1299);
            zero_or_more_enum_elements89=zero_or_more_enum_elements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_enum_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, zero_or_more_enum_elements89.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleat_least_one_enum_elementEx; /* Prevent compiler warnings */
    ruleat_least_one_enum_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end at_least_one_enum_element */

/** 
 * $ANTLR start zero_or_more_enum_elements
 * ProtoJS.g:259:1: zero_or_more_enum_elements : ( ( enum_element )* -> ( WS[\",\"] WS[\"\\n\"] enum_element )* ) ;
 */
static ProtoJSParser_zero_or_more_enum_elements_return
zero_or_more_enum_elements(pProtoJSParser ctx)
{   
    ProtoJSParser_zero_or_more_enum_elements_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_enum_element_return enum_element90;
    #undef	RETURN_TYPE_enum_element90
    #define	RETURN_TYPE_enum_element90 ProtoJSParser_enum_element_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_enum_element;
    /* Initialize rule variables
     */


    root_0 = NULL;

    enum_element90.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_enum_element   = NULL;
    #define CREATE_stream_enum_element  if (stream_enum_element == NULL) {stream_enum_element = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule enum_element"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:259:28: ( ( ( enum_element )* -> ( WS[\",\"] WS[\"\\n\"] enum_element )* ) )
        // ProtoJS.g:259:30: ( ( enum_element )* -> ( WS[\",\"] WS[\"\\n\"] enum_element )* )
        {
            // ProtoJS.g:259:30: ( ( enum_element )* -> ( WS[\",\"] WS[\"\\n\"] enum_element )* )
            // ProtoJS.g:259:31: ( enum_element )*
            {

                // ProtoJS.g:259:31: ( enum_element )*

                for (;;)
                {
                    int alt16=2;
                    switch ( LA(1) ) 
                    {
                    case IDENTIFIER:
                    	{
                    		alt16=1;
                    	}
                        break;

                    }

                    switch (alt16) 
                    {
                	case 1:
                	    // ProtoJS.g:259:31: enum_element
                	    {
                	        FOLLOWPUSH(FOLLOW_enum_element_in_zero_or_more_enum_elements1307);
                	        enum_element90=enum_element(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulezero_or_more_enum_elementsEx;
                	        }

                	        CREATE_stream_enum_element; stream_enum_element->add(stream_enum_element, enum_element90.tree, NULL);

                	    }
                	    break;

                	default:
                	    goto loop16;	/* break out of the loop */
                	    break;
                    }
                }
                loop16: ; /* Jump out to here if this rule does not match */


                 
                /* AST REWRITE
                 * elements          : enum_element
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 259:45: -> ( WS[\",\"] WS[\"\\n\"] enum_element )*
                	{
                	    // ProtoJS.g:259:48: ( WS[\",\"] WS[\"\\n\"] enum_element )*
                	    {
                	    	while ( (stream_enum_element != NULL && stream_enum_element->hasNext(stream_enum_element))  )
                	    	{
                	    		ADAPTOR->addChild(ADAPTOR, root_0, 
                	    		#if 1 == 2
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(","))
                	    		#else
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)",")
                	    		#endif
                	    		);
                	    		ADAPTOR->addChild(ADAPTOR, root_0, 
                	    		#if 1 == 2
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    		#else
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    		#endif
                	    		);
                	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_enum_element == NULL ? NULL : stream_enum_element->nextTree(stream_enum_element));

                	    	}
                	    	if (stream_enum_element != NULL) stream_enum_element->reset(stream_enum_element);

                	    }

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulezero_or_more_enum_elementsEx; /* Prevent compiler warnings */
    rulezero_or_more_enum_elementsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_enum_element != NULL) stream_enum_element->free(stream_enum_element);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end zero_or_more_enum_elements */

/** 
 * $ANTLR start enum_element
 * ProtoJS.g:261:1: enum_element : ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] integer ) ;
 */
static ProtoJSParser_enum_element_return
enum_element(pProtoJSParser ctx)
{   
    ProtoJSParser_enum_element_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER91;
    pANTLR3_COMMON_TOKEN    EQUALS92;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR94;
    ProtoJSParser_integer_return integer93;
    #undef	RETURN_TYPE_integer93
    #define	RETURN_TYPE_integer93 ProtoJSParser_integer_return

    pANTLR3_BASE_TREE IDENTIFIER91_tree;
    pANTLR3_BASE_TREE EQUALS92_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR94_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUALS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer;
    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER91       = NULL;
    EQUALS92       = NULL;
    ITEM_TERMINATOR94       = NULL;
    integer93.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER91_tree   = NULL;
    EQUALS92_tree   = NULL;
    ITEM_TERMINATOR94_tree   = NULL;

    stream_EQUALS   = NULL;
    #define CREATE_stream_EQUALS  if (stream_EQUALS == NULL) {stream_EQUALS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUALS"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_integer   = NULL;
    #define CREATE_stream_integer  if (stream_integer == NULL) {stream_integer = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:262:2: ( ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] integer ) )
        // ProtoJS.g:262:4: ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] integer )
        {
            // ProtoJS.g:262:4: ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] integer )
            // ProtoJS.g:262:5: IDENTIFIER EQUALS integer ITEM_TERMINATOR
            {
                IDENTIFIER91 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enum_element1332); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_elementEx;
                }
                 
                CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER91, NULL);

                EQUALS92 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_enum_element1334); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_elementEx;
                }
                 
                CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS92, NULL);

                FOLLOWPUSH(FOLLOW_integer_in_enum_element1336);
                integer93=integer(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleenum_elementEx;
                }

                CREATE_stream_integer; stream_integer->add(stream_integer, integer93.tree, NULL);
                ITEM_TERMINATOR94 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_enum_element1338); 
                if  (HASEXCEPTION())
                {
                    goto ruleenum_elementEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR94, NULL);


                 
                /* AST REWRITE
                 * elements          : IDENTIFIER, integer
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 262:47: -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] integer
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_integer == NULL ? NULL : stream_integer->nextTree(stream_integer));

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineEnumValue( ctx, 	(SCOPE_TOP(enum_def))->enumName, 	(SCOPE_TOP(enum_def))->enumList, (IDENTIFIER91->getText(IDENTIFIER91)), (STRSTREAM->toStringTT(STRSTREAM, integer93.start, integer93.stop)) );
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenum_elementEx; /* Prevent compiler warnings */
    ruleenum_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EQUALS != NULL) stream_EQUALS->free(stream_EQUALS);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_integer != NULL) stream_integer->free(stream_integer);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end enum_element */

/** 
 * $ANTLR start enum_identifier
 * ProtoJS.g:267:1: enum_identifier : IDENTIFIER ;
 */
static ProtoJSParser_enum_identifier_return
enum_identifier(pProtoJSParser ctx)
{   
    ProtoJSParser_enum_identifier_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER95;

    pANTLR3_BASE_TREE IDENTIFIER95_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER95       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER95_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:268:5: ( IDENTIFIER )
        // ProtoJS.g:268:7: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER95 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enum_identifier1381); 
            if  (HASEXCEPTION())
            {
                goto ruleenum_identifierEx;
            }

            IDENTIFIER95_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER95));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER95_tree);

            {

                            	(SCOPE_TOP(enum_def))->enumName=stringDup((IDENTIFIER95->getText(IDENTIFIER95)));
                      
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleenum_identifierEx; /* Prevent compiler warnings */
    ruleenum_identifierEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end enum_identifier */

/** 
 * $ANTLR start flags_def
 * ProtoJS.g:274:1: flags_def : ( flags flag_identifier BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] flag_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ) ;
 */
static ProtoJSParser_flags_def_return
flags_def(pProtoJSParser ctx)
{   
    ProtoJSParser_flags_def_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BLOCK_OPEN98;
    pANTLR3_COMMON_TOKEN    BLOCK_CLOSE100;
    ProtoJSParser_flags_return flags96;
    #undef	RETURN_TYPE_flags96
    #define	RETURN_TYPE_flags96 ProtoJSParser_flags_return

    ProtoJSParser_flag_identifier_return flag_identifier97;
    #undef	RETURN_TYPE_flag_identifier97
    #define	RETURN_TYPE_flag_identifier97 ProtoJSParser_flag_identifier_return

    ProtoJSParser_at_least_one_flag_element_return at_least_one_flag_element99;
    #undef	RETURN_TYPE_at_least_one_flag_element99
    #define	RETURN_TYPE_at_least_one_flag_element99 ProtoJSParser_at_least_one_flag_element_return

    pANTLR3_BASE_TREE BLOCK_OPEN98_tree;
    pANTLR3_BASE_TREE BLOCK_CLOSE100_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_OPEN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BLOCK_CLOSE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_at_least_one_flag_element;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_flags;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_flag_identifier;
    /* Initialize rule variables
     */

    ctx->pProtoJSParser_flags_defTop = pProtoJSParser_flags_defPush(ctx);
    root_0 = NULL;


            	(SCOPE_TOP(flags_def))->flagList=antlr3ListNew(1);
            
        
    BLOCK_OPEN98       = NULL;
    BLOCK_CLOSE100       = NULL;
    flags96.tree = NULL;

    flag_identifier97.tree = NULL;

    at_least_one_flag_element99.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    BLOCK_OPEN98_tree   = NULL;
    BLOCK_CLOSE100_tree   = NULL;

    stream_BLOCK_OPEN   = NULL;
    #define CREATE_stream_BLOCK_OPEN  if (stream_BLOCK_OPEN == NULL) {stream_BLOCK_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_OPEN"); } 
    stream_BLOCK_CLOSE   = NULL;
    #define CREATE_stream_BLOCK_CLOSE  if (stream_BLOCK_CLOSE == NULL) {stream_BLOCK_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BLOCK_CLOSE"); } 
    stream_at_least_one_flag_element   = NULL;
    #define CREATE_stream_at_least_one_flag_element  if (stream_at_least_one_flag_element == NULL) {stream_at_least_one_flag_element = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule at_least_one_flag_element"); }
    stream_flags   = NULL;
    #define CREATE_stream_flags  if (stream_flags == NULL) {stream_flags = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule flags"); }
    stream_flag_identifier   = NULL;
    #define CREATE_stream_flag_identifier  if (stream_flag_identifier == NULL) {stream_flag_identifier = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule flag_identifier"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:285:2: ( ( flags flag_identifier BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] flag_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ) )
        // ProtoJS.g:285:4: ( flags flag_identifier BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] flag_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] )
        {
            // ProtoJS.g:285:4: ( flags flag_identifier BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"] -> WS[\"\\t\"] flag_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] )
            // ProtoJS.g:285:6: flags flag_identifier BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE
            {
                FOLLOWPUSH(FOLLOW_flags_in_flags_def1428);
                flags96=flags(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleflags_defEx;
                }

                CREATE_stream_flags; stream_flags->add(stream_flags, flags96.tree, NULL);
                FOLLOWPUSH(FOLLOW_flag_identifier_in_flags_def1430);
                flag_identifier97=flag_identifier(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleflags_defEx;
                }

                CREATE_stream_flag_identifier; stream_flag_identifier->add(stream_flag_identifier, flag_identifier97.tree, NULL);
                BLOCK_OPEN98 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_OPEN, &FOLLOW_BLOCK_OPEN_in_flags_def1432); 
                if  (HASEXCEPTION())
                {
                    goto ruleflags_defEx;
                }
                 
                CREATE_stream_BLOCK_OPEN; stream_BLOCK_OPEN->add(stream_BLOCK_OPEN, BLOCK_OPEN98, NULL);

                FOLLOWPUSH(FOLLOW_at_least_one_flag_element_in_flags_def1434);
                at_least_one_flag_element99=at_least_one_flag_element(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleflags_defEx;
                }

                CREATE_stream_at_least_one_flag_element; stream_at_least_one_flag_element->add(stream_at_least_one_flag_element, at_least_one_flag_element99.tree, NULL);
                BLOCK_CLOSE100 = (pANTLR3_COMMON_TOKEN) MATCHT(BLOCK_CLOSE, &FOLLOW_BLOCK_CLOSE_in_flags_def1436); 
                if  (HASEXCEPTION())
                {
                    goto ruleflags_defEx;
                }
                 
                CREATE_stream_BLOCK_CLOSE; stream_BLOCK_CLOSE->add(stream_BLOCK_CLOSE, BLOCK_CLOSE100, NULL);


                 
                /* AST REWRITE
                 * elements          : at_least_one_flag_element, at_least_one_flag_element, BLOCK_OPEN, BLOCK_CLOSE, flag_identifier, BLOCK_CLOSE, BLOCK_OPEN
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 286:12: -> {ctx->pProtoJSParser_SymbolsStack_limit<=1}? QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] COLON[\"=\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"] ITEM_TERMINATOR[\";\"] WS[\"\\n\"]
                	if (ctx->pProtoJSParser_SymbolsStack_limit<=1) 
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT("="))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)"=")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Flags"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Flags")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, DECIMAL_LITERAL, TOKTEXT("123456"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DECIMAL_LITERAL, (pANTLR3_UINT8)"123456")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_flag_element == NULL ? NULL : stream_at_least_one_flag_element->nextTree(stream_at_least_one_flag_element));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );

                	}
                	else // 288:12: -> WS[\"\\t\"] flag_identifier COLON[\":\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.Flags\"] PAREN_OPEN[\"(\"] DECIMAL_LITERAL[\"123456\"] COMMA[\",\"] QUOTE[\"\\\"\"] QUALIFIEDIDENTIFIER[qualifyType(ctx,$flags.text,$flags_def::flagName)] QUOTE[\"\\\"\"] COMMA[\",\"] BLOCK_OPEN WS[\"\\n\"] at_least_one_flag_element BLOCK_CLOSE PAREN_CLOSE[\")\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_flag_identifier == NULL ? NULL : stream_flag_identifier->nextTree(stream_flag_identifier));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO.Flags"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.Flags")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, DECIMAL_LITERAL, TOKTEXT("123456"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DECIMAL_LITERAL, (pANTLR3_UINT8)"123456")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName)))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType(ctx,(STRSTREAM->toStringTT(STRSTREAM, flags96.start, flags96.stop)),	(SCOPE_TOP(flags_def))->flagName))
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUOTE, TOKTEXT("\""))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUOTE, (pANTLR3_UINT8)"\"")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_OPEN == NULL ? NULL : stream_BLOCK_OPEN->nextNode(stream_BLOCK_OPEN));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_at_least_one_flag_element == NULL ? NULL : stream_at_least_one_flag_element->nextTree(stream_at_least_one_flag_element));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_BLOCK_CLOSE == NULL ? NULL : stream_BLOCK_CLOSE->nextNode(stream_BLOCK_CLOSE));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineFlag( ctx, 	(SCOPE_TOP(flags_def))->flagName, 	(SCOPE_TOP(flags_def))->flagList, 	(SCOPE_TOP(flags_def))->flagBits);
                            	(SCOPE_TOP(flags_def))->flagList->free(	(SCOPE_TOP(flags_def))->flagList);
                            stringFree(	(SCOPE_TOP(flags_def))->flagName);
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleflags_defEx; /* Prevent compiler warnings */
    ruleflags_defEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_BLOCK_OPEN != NULL) stream_BLOCK_OPEN->free(stream_BLOCK_OPEN);
        if (stream_BLOCK_CLOSE != NULL) stream_BLOCK_CLOSE->free(stream_BLOCK_CLOSE);
        if (stream_at_least_one_flag_element != NULL) stream_at_least_one_flag_element->free(stream_at_least_one_flag_element);
        if (stream_flags != NULL) stream_flags->free(stream_flags);
        if (stream_flag_identifier != NULL) stream_flag_identifier->free(stream_flag_identifier);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_flags_defPop(ctx);

    return retval;
}
/* $ANTLR end flags_def */

/** 
 * $ANTLR start flag_identifier
 * ProtoJS.g:296:1: flag_identifier : IDENTIFIER ;
 */
static ProtoJSParser_flag_identifier_return
flag_identifier(pProtoJSParser ctx)
{   
    ProtoJSParser_flag_identifier_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER101;

    pANTLR3_BASE_TREE IDENTIFIER101_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER101       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER101_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:297:2: ( IDENTIFIER )
        // ProtoJS.g:297:4: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER101 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_flag_identifier1598); 
            if  (HASEXCEPTION())
            {
                goto ruleflag_identifierEx;
            }

            IDENTIFIER101_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER101));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER101_tree);

            {

                            	(SCOPE_TOP(flags_def))->flagName=stringDup((IDENTIFIER101->getText(IDENTIFIER101)));
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleflag_identifierEx; /* Prevent compiler warnings */
    ruleflag_identifierEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end flag_identifier */

/** 
 * $ANTLR start at_least_one_flag_element
 * ProtoJS.g:302:1: at_least_one_flag_element : flag_element zero_or_more_flag_elements ;
 */
static ProtoJSParser_at_least_one_flag_element_return
at_least_one_flag_element(pProtoJSParser ctx)
{   
    ProtoJSParser_at_least_one_flag_element_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_flag_element_return flag_element102;
    #undef	RETURN_TYPE_flag_element102
    #define	RETURN_TYPE_flag_element102 ProtoJSParser_flag_element_return

    ProtoJSParser_zero_or_more_flag_elements_return zero_or_more_flag_elements103;
    #undef	RETURN_TYPE_zero_or_more_flag_elements103
    #define	RETURN_TYPE_zero_or_more_flag_elements103 ProtoJSParser_zero_or_more_flag_elements_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    flag_element102.tree = NULL;

    zero_or_more_flag_elements103.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:302:26: ( flag_element zero_or_more_flag_elements )
        // ProtoJS.g:302:28: flag_element zero_or_more_flag_elements
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_flag_element_in_at_least_one_flag_element1616);
            flag_element102=flag_element(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_flag_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, flag_element102.tree);
            FOLLOWPUSH(FOLLOW_zero_or_more_flag_elements_in_at_least_one_flag_element1618);
            zero_or_more_flag_elements103=zero_or_more_flag_elements(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleat_least_one_flag_elementEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, zero_or_more_flag_elements103.tree);

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleat_least_one_flag_elementEx; /* Prevent compiler warnings */
    ruleat_least_one_flag_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end at_least_one_flag_element */

/** 
 * $ANTLR start zero_or_more_flag_elements
 * ProtoJS.g:304:1: zero_or_more_flag_elements : ( ( flag_element )* -> ( COMMA[\",\"] WS[\"\\n\"] flag_element )* ) ;
 */
static ProtoJSParser_zero_or_more_flag_elements_return
zero_or_more_flag_elements(pProtoJSParser ctx)
{   
    ProtoJSParser_zero_or_more_flag_elements_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_flag_element_return flag_element104;
    #undef	RETURN_TYPE_flag_element104
    #define	RETURN_TYPE_flag_element104 ProtoJSParser_flag_element_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_flag_element;
    /* Initialize rule variables
     */


    root_0 = NULL;

    flag_element104.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_flag_element   = NULL;
    #define CREATE_stream_flag_element  if (stream_flag_element == NULL) {stream_flag_element = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule flag_element"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:304:28: ( ( ( flag_element )* -> ( COMMA[\",\"] WS[\"\\n\"] flag_element )* ) )
        // ProtoJS.g:304:30: ( ( flag_element )* -> ( COMMA[\",\"] WS[\"\\n\"] flag_element )* )
        {
            // ProtoJS.g:304:30: ( ( flag_element )* -> ( COMMA[\",\"] WS[\"\\n\"] flag_element )* )
            // ProtoJS.g:304:31: ( flag_element )*
            {

                // ProtoJS.g:304:31: ( flag_element )*

                for (;;)
                {
                    int alt17=2;
                    switch ( LA(1) ) 
                    {
                    case IDENTIFIER:
                    	{
                    		alt17=1;
                    	}
                        break;

                    }

                    switch (alt17) 
                    {
                	case 1:
                	    // ProtoJS.g:304:31: flag_element
                	    {
                	        FOLLOWPUSH(FOLLOW_flag_element_in_zero_or_more_flag_elements1627);
                	        flag_element104=flag_element(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulezero_or_more_flag_elementsEx;
                	        }

                	        CREATE_stream_flag_element; stream_flag_element->add(stream_flag_element, flag_element104.tree, NULL);

                	    }
                	    break;

                	default:
                	    goto loop17;	/* break out of the loop */
                	    break;
                    }
                }
                loop17: ; /* Jump out to here if this rule does not match */


                 
                /* AST REWRITE
                 * elements          : flag_element
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 304:45: -> ( COMMA[\",\"] WS[\"\\n\"] flag_element )*
                	{
                	    // ProtoJS.g:304:48: ( COMMA[\",\"] WS[\"\\n\"] flag_element )*
                	    {
                	    	while ( (stream_flag_element != NULL && stream_flag_element->hasNext(stream_flag_element))  )
                	    	{
                	    		ADAPTOR->addChild(ADAPTOR, root_0, 
                	    		#if 1 == 2
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    		#else
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    		#endif
                	    		);
                	    		ADAPTOR->addChild(ADAPTOR, root_0, 
                	    		#if 1 == 2
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n"))
                	    		#else
                	    			(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n")
                	    		#endif
                	    		);
                	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_flag_element == NULL ? NULL : stream_flag_element->nextTree(stream_flag_element));

                	    	}
                	    	if (stream_flag_element != NULL) stream_flag_element->reset(stream_flag_element);

                	    }

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulezero_or_more_flag_elementsEx; /* Prevent compiler warnings */
    rulezero_or_more_flag_elementsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_flag_element != NULL) stream_flag_element->free(stream_flag_element);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end zero_or_more_flag_elements */

/** 
 * $ANTLR start flag_element
 * ProtoJS.g:305:1: flag_element : ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] WS[\" \"] integer ) ;
 */
static ProtoJSParser_flag_element_return
flag_element(pProtoJSParser ctx)
{   
    ProtoJSParser_flag_element_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER105;
    pANTLR3_COMMON_TOKEN    EQUALS106;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR108;
    ProtoJSParser_integer_return integer107;
    #undef	RETURN_TYPE_integer107
    #define	RETURN_TYPE_integer107 ProtoJSParser_integer_return

    pANTLR3_BASE_TREE IDENTIFIER105_tree;
    pANTLR3_BASE_TREE EQUALS106_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR108_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUALS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_integer;
    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER105       = NULL;
    EQUALS106       = NULL;
    ITEM_TERMINATOR108       = NULL;
    integer107.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER105_tree   = NULL;
    EQUALS106_tree   = NULL;
    ITEM_TERMINATOR108_tree   = NULL;

    stream_EQUALS   = NULL;
    #define CREATE_stream_EQUALS  if (stream_EQUALS == NULL) {stream_EQUALS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUALS"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_integer   = NULL;
    #define CREATE_stream_integer  if (stream_integer == NULL) {stream_integer = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule integer"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:306:2: ( ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] WS[\" \"] integer ) )
        // ProtoJS.g:306:4: ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] WS[\" \"] integer )
        {
            // ProtoJS.g:306:4: ( IDENTIFIER EQUALS integer ITEM_TERMINATOR -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] WS[\" \"] integer )
            // ProtoJS.g:306:6: IDENTIFIER EQUALS integer ITEM_TERMINATOR
            {
                IDENTIFIER105 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_flag_element1652); 
                if  (HASEXCEPTION())
                {
                    goto ruleflag_elementEx;
                }
                 
                CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER105, NULL);

                EQUALS106 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_flag_element1654); 
                if  (HASEXCEPTION())
                {
                    goto ruleflag_elementEx;
                }
                 
                CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS106, NULL);

                FOLLOWPUSH(FOLLOW_integer_in_flag_element1656);
                integer107=integer(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleflag_elementEx;
                }

                CREATE_stream_integer; stream_integer->add(stream_integer, integer107.tree, NULL);
                ITEM_TERMINATOR108 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_flag_element1658); 
                if  (HASEXCEPTION())
                {
                    goto ruleflag_elementEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR108, NULL);


                 
                /* AST REWRITE
                 * elements          : integer, IDENTIFIER
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 306:48: -> WS[\"\\t\"] WS[\"\\t\"] IDENTIFIER WS[\" \"] COLON[\":\"] WS[\" \"] integer
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_integer == NULL ? NULL : stream_integer->nextTree(stream_integer));

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            defineFlagValue( ctx, 	(SCOPE_TOP(flags_def))->flagName, 	(SCOPE_TOP(flags_def))->flagList, (IDENTIFIER105->getText(IDENTIFIER105)) , (STRSTREAM->toStringTT(STRSTREAM, integer107.start, integer107.stop)));
                        
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleflag_elementEx; /* Prevent compiler warnings */
    ruleflag_elementEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EQUALS != NULL) stream_EQUALS->free(stream_EQUALS);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_integer != NULL) stream_integer->free(stream_integer);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end flag_element */

/** 
 * $ANTLR start field
 * ProtoJS.g:312:1: field : ( ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR ) -> WS[\"\\t\"] field_name COLON[\":\"] WS[\" \"] BLOCK_OPEN[\"{\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"options:\"] WS[\" \"] default_value none COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"multiplicity:\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.\"] multiplicity COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"type:\"] WS[\" \"] IDENTIFIER[\"function\"] PAREN_OPEN[\"(\"] PAREN_CLOSE[\")\"] BLOCK_OPEN[\"{\"] IDENTIFIER[\"return\"] WS[\" \"] multiplicitive_type field_type ITEM_TERMINATOR[\";\"] BLOCK_CLOSE[\"}\"] COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"id:\"] WS[\" \"] field_offset WS[\"\\n\\t\"] BLOCK_CLOSE[\"}\"] ) ;
 */
static ProtoJSParser_field_return
field(pProtoJSParser ctx)
{   
    ProtoJSParser_field_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUALS113;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR117;
    ProtoJSParser_multiplicity_return multiplicity109;
    #undef	RETURN_TYPE_multiplicity109
    #define	RETURN_TYPE_multiplicity109 ProtoJSParser_multiplicity_return

    ProtoJSParser_multiplicitive_type_return multiplicitive_type110;
    #undef	RETURN_TYPE_multiplicitive_type110
    #define	RETURN_TYPE_multiplicitive_type110 ProtoJSParser_multiplicitive_type_return

    ProtoJSParser_field_type_return field_type111;
    #undef	RETURN_TYPE_field_type111
    #define	RETURN_TYPE_field_type111 ProtoJSParser_field_type_return

    ProtoJSParser_field_name_return field_name112;
    #undef	RETURN_TYPE_field_name112
    #define	RETURN_TYPE_field_name112 ProtoJSParser_field_name_return

    ProtoJSParser_field_offset_return field_offset114;
    #undef	RETURN_TYPE_field_offset114
    #define	RETURN_TYPE_field_offset114 ProtoJSParser_field_offset_return

    ProtoJSParser_default_value_return default_value115;
    #undef	RETURN_TYPE_default_value115
    #define	RETURN_TYPE_default_value115 ProtoJSParser_default_value_return

    ProtoJSParser_none_return none116;
    #undef	RETURN_TYPE_none116
    #define	RETURN_TYPE_none116 ProtoJSParser_none_return

    pANTLR3_BASE_TREE EQUALS113_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR117_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUALS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_field_name;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_field_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_field_offset;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_default_value;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_none;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_multiplicitive_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_multiplicity;
    /* Initialize rule variables
     */

    ctx->pProtoJSParser_fieldTop = pProtoJSParser_fieldPush(ctx);
    root_0 = NULL;

    	(SCOPE_TOP(field))->defaultValue=NULL; 	(SCOPE_TOP(field))->isNumericType=0;	(SCOPE_TOP(field))->isRepeated=0;	(SCOPE_TOP(field))->isRequired=0;
    EQUALS113       = NULL;
    ITEM_TERMINATOR117       = NULL;
    multiplicity109.tree = NULL;

    multiplicitive_type110.tree = NULL;

    field_type111.tree = NULL;

    field_name112.tree = NULL;

    field_offset114.tree = NULL;

    default_value115.tree = NULL;

    none116.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    EQUALS113_tree   = NULL;
    ITEM_TERMINATOR117_tree   = NULL;

    stream_EQUALS   = NULL;
    #define CREATE_stream_EQUALS  if (stream_EQUALS == NULL) {stream_EQUALS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUALS"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_field_name   = NULL;
    #define CREATE_stream_field_name  if (stream_field_name == NULL) {stream_field_name = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule field_name"); }
    stream_field_type   = NULL;
    #define CREATE_stream_field_type  if (stream_field_type == NULL) {stream_field_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule field_type"); }
    stream_field_offset   = NULL;
    #define CREATE_stream_field_offset  if (stream_field_offset == NULL) {stream_field_offset = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule field_offset"); }
    stream_default_value   = NULL;
    #define CREATE_stream_default_value  if (stream_default_value == NULL) {stream_default_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule default_value"); }
    stream_none   = NULL;
    #define CREATE_stream_none  if (stream_none == NULL) {stream_none = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule none"); }
    stream_multiplicitive_type   = NULL;
    #define CREATE_stream_multiplicitive_type  if (stream_multiplicitive_type == NULL) {stream_multiplicitive_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule multiplicitive_type"); }
    stream_multiplicity   = NULL;
    #define CREATE_stream_multiplicity  if (stream_multiplicity == NULL) {stream_multiplicity = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule multiplicity"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:324:5: ( ( ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR ) -> WS[\"\\t\"] field_name COLON[\":\"] WS[\" \"] BLOCK_OPEN[\"{\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"options:\"] WS[\" \"] default_value none COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"multiplicity:\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.\"] multiplicity COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"type:\"] WS[\" \"] IDENTIFIER[\"function\"] PAREN_OPEN[\"(\"] PAREN_CLOSE[\")\"] BLOCK_OPEN[\"{\"] IDENTIFIER[\"return\"] WS[\" \"] multiplicitive_type field_type ITEM_TERMINATOR[\";\"] BLOCK_CLOSE[\"}\"] COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"id:\"] WS[\" \"] field_offset WS[\"\\n\\t\"] BLOCK_CLOSE[\"}\"] ) )
        // ProtoJS.g:325:7: ( ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR ) -> WS[\"\\t\"] field_name COLON[\":\"] WS[\" \"] BLOCK_OPEN[\"{\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"options:\"] WS[\" \"] default_value none COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"multiplicity:\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.\"] multiplicity COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"type:\"] WS[\" \"] IDENTIFIER[\"function\"] PAREN_OPEN[\"(\"] PAREN_CLOSE[\")\"] BLOCK_OPEN[\"{\"] IDENTIFIER[\"return\"] WS[\" \"] multiplicitive_type field_type ITEM_TERMINATOR[\";\"] BLOCK_CLOSE[\"}\"] COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"id:\"] WS[\" \"] field_offset WS[\"\\n\\t\"] BLOCK_CLOSE[\"}\"] )
        {
            // ProtoJS.g:325:7: ( ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR ) -> WS[\"\\t\"] field_name COLON[\":\"] WS[\" \"] BLOCK_OPEN[\"{\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"options:\"] WS[\" \"] default_value none COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"multiplicity:\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.\"] multiplicity COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"type:\"] WS[\" \"] IDENTIFIER[\"function\"] PAREN_OPEN[\"(\"] PAREN_CLOSE[\")\"] BLOCK_OPEN[\"{\"] IDENTIFIER[\"return\"] WS[\" \"] multiplicitive_type field_type ITEM_TERMINATOR[\";\"] BLOCK_CLOSE[\"}\"] COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"id:\"] WS[\" \"] field_offset WS[\"\\n\\t\"] BLOCK_CLOSE[\"}\"] )
            // ProtoJS.g:325:9: ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR )
            {
                // ProtoJS.g:325:9: ( multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR )
                // ProtoJS.g:325:11: multiplicity ( multiplicitive_type | field_type ) field_name EQUALS field_offset ( default_value | none ) ITEM_TERMINATOR
                {
                    FOLLOWPUSH(FOLLOW_multiplicity_in_field1730);
                    multiplicity109=multiplicity(ctx);

                    FOLLOWPOP();
                    if  (HASEXCEPTION())
                    {
                        goto rulefieldEx;
                    }

                    CREATE_stream_multiplicity; stream_multiplicity->add(stream_multiplicity, multiplicity109.tree, NULL);

                    // ProtoJS.g:325:24: ( multiplicitive_type | field_type )
                    {
                        int alt18=2;
                        switch ( LA(1) ) 
                        {
                        case NORMAL:
                        case VECTOR2F:
                        case VECTOR2D:
                        case VECTOR3F:
                        case VECTOR3D:
                        case VECTOR4F:
                        case VECTOR4D:
                        case UNITQUATERNION:
                        case QUATERNION:
                        case BOUNDINGSPHERE3F:
                        case BOUNDINGSPHERE3D:
                        case BOUNDINGBOX3F3F:
                        case BOUNDINGBOX3D3F:
                        	{
                        		alt18=1;
                        	}
                            break;
                        case QUALIFIEDIDENTIFIER:
                        case IDENTIFIER:
                        case FLOAT:
                        case DOUBLE:
                        case UINT32:
                        case INT32:
                        case SINT32:
                        case FIXED32:
                        case SFIXED32:
                        case UINT64:
                        case INT64:
                        case SINT64:
                        case FIXED64:
                        case SFIXED64:
                        case BOOL:
                        case STRING:
                        case BYTES:
                        case UINT8:
                        case INT8:
                        case SINT8:
                        case FIXED8:
                        case SFIXED8:
                        case INT16:
                        case SINT16:
                        case FIXED16:
                        case SFIXED16:
                        case UINT16:
                        case ANGLE:
                        case TIME:
                        case DURATION:
                        case UUID:
                        case SHA256:
                        	{
                        		alt18=2;
                        	}
                            break;

                        default:
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 18;
                            EXCEPTION->state        = 0;


                            goto rulefieldEx;
                        }

                        switch (alt18) 
                        {
                    	case 1:
                    	    // ProtoJS.g:325:25: multiplicitive_type
                    	    {
                    	        FOLLOWPUSH(FOLLOW_multiplicitive_type_in_field1733);
                    	        multiplicitive_type110=multiplicitive_type(ctx);

                    	        FOLLOWPOP();
                    	        if  (HASEXCEPTION())
                    	        {
                    	            goto rulefieldEx;
                    	        }

                    	        CREATE_stream_multiplicitive_type; stream_multiplicitive_type->add(stream_multiplicitive_type, multiplicitive_type110.tree, NULL);

                    	    }
                    	    break;
                    	case 2:
                    	    // ProtoJS.g:325:45: field_type
                    	    {
                    	        FOLLOWPUSH(FOLLOW_field_type_in_field1735);
                    	        field_type111=field_type(ctx);

                    	        FOLLOWPOP();
                    	        if  (HASEXCEPTION())
                    	        {
                    	            goto rulefieldEx;
                    	        }

                    	        CREATE_stream_field_type; stream_field_type->add(stream_field_type, field_type111.tree, NULL);

                    	    }
                    	    break;

                        }
                    }
                    FOLLOWPUSH(FOLLOW_field_name_in_field1738);
                    field_name112=field_name(ctx);

                    FOLLOWPOP();
                    if  (HASEXCEPTION())
                    {
                        goto rulefieldEx;
                    }

                    CREATE_stream_field_name; stream_field_name->add(stream_field_name, field_name112.tree, NULL);
                    EQUALS113 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_field1740); 
                    if  (HASEXCEPTION())
                    {
                        goto rulefieldEx;
                    }
                     
                    CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS113, NULL);

                    FOLLOWPUSH(FOLLOW_field_offset_in_field1742);
                    field_offset114=field_offset(ctx);

                    FOLLOWPOP();
                    if  (HASEXCEPTION())
                    {
                        goto rulefieldEx;
                    }

                    CREATE_stream_field_offset; stream_field_offset->add(stream_field_offset, field_offset114.tree, NULL);

                    // ProtoJS.g:325:88: ( default_value | none )
                    {
                        int alt19=2;
                        switch ( LA(1) ) 
                        {
                        case SQBRACKET_OPEN:
                        	{
                        		alt19=1;
                        	}
                            break;
                        case ITEM_TERMINATOR:
                        case DOT:
                        	{
                        		alt19=2;
                        	}
                            break;

                        default:
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 19;
                            EXCEPTION->state        = 0;


                            goto rulefieldEx;
                        }

                        switch (alt19) 
                        {
                    	case 1:
                    	    // ProtoJS.g:325:89: default_value
                    	    {
                    	        FOLLOWPUSH(FOLLOW_default_value_in_field1745);
                    	        default_value115=default_value(ctx);

                    	        FOLLOWPOP();
                    	        if  (HASEXCEPTION())
                    	        {
                    	            goto rulefieldEx;
                    	        }

                    	        CREATE_stream_default_value; stream_default_value->add(stream_default_value, default_value115.tree, NULL);

                    	    }
                    	    break;
                    	case 2:
                    	    // ProtoJS.g:325:103: none
                    	    {
                    	        FOLLOWPUSH(FOLLOW_none_in_field1747);
                    	        none116=none(ctx);

                    	        FOLLOWPOP();
                    	        if  (HASEXCEPTION())
                    	        {
                    	            goto rulefieldEx;
                    	        }

                    	        CREATE_stream_none; stream_none->add(stream_none, none116.tree, NULL);

                    	    }
                    	    break;

                        }
                    }
                    ITEM_TERMINATOR117 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_field1750); 
                    if  (HASEXCEPTION())
                    {
                        goto rulefieldEx;
                    }
                     
                    CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR117, NULL);


                }


                 
                /* AST REWRITE
                 * elements          : field_name, none, default_value, multiplicity, multiplicitive_type, ITEM_TERMINATOR, field_offset, field_type
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 326:8: -> WS[\"\\t\"] field_name COLON[\":\"] WS[\" \"] BLOCK_OPEN[\"{\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"options:\"] WS[\" \"] default_value none COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"multiplicity:\"] WS[\" \"] QUALIFIEDIDENTIFIER[\"PROTO.\"] multiplicity COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"type:\"] WS[\" \"] IDENTIFIER[\"function\"] PAREN_OPEN[\"(\"] PAREN_CLOSE[\")\"] BLOCK_OPEN[\"{\"] IDENTIFIER[\"return\"] WS[\" \"] multiplicitive_type field_type ITEM_TERMINATOR[\";\"] BLOCK_CLOSE[\"}\"] COMMA[\",\"] WS[\"\\n\\t\\t\"] IDENTIFIERCOLON[\"id:\"] WS[\" \"] field_offset WS[\"\\n\\t\"] BLOCK_CLOSE[\"}\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_field_name == NULL ? NULL : stream_field_name->nextTree(stream_field_name));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_OPEN, TOKTEXT("{"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_OPEN, (pANTLR3_UINT8)"{")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n\t\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n\t\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIERCOLON, TOKTEXT("options:"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIERCOLON, (pANTLR3_UINT8)"options:")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_default_value == NULL ? NULL : stream_default_value->nextTree(stream_default_value));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_none == NULL ? NULL : stream_none->nextTree(stream_none));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n\t\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n\t\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIERCOLON, TOKTEXT("multiplicity:"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIERCOLON, (pANTLR3_UINT8)"multiplicity:")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO."))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_multiplicity == NULL ? NULL : stream_multiplicity->nextTree(stream_multiplicity));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n\t\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n\t\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIERCOLON, TOKTEXT("type:"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIERCOLON, (pANTLR3_UINT8)"type:")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT("function"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)"function")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_OPEN, TOKTEXT("("))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_OPEN, (pANTLR3_UINT8)"(")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, PAREN_CLOSE, TOKTEXT(")"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PAREN_CLOSE, (pANTLR3_UINT8)")")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_OPEN, TOKTEXT("{"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_OPEN, (pANTLR3_UINT8)"{")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT("return"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)"return")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_multiplicitive_type == NULL ? NULL : stream_multiplicitive_type->nextTree(stream_multiplicitive_type));
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_field_type == NULL ? NULL : stream_field_type->nextTree(stream_field_type));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, ITEM_TERMINATOR, TOKTEXT(";"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ITEM_TERMINATOR, (pANTLR3_UINT8)";")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_CLOSE, TOKTEXT("}"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_CLOSE, (pANTLR3_UINT8)"}")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n\t\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n\t\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIERCOLON, TOKTEXT("id:"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIERCOLON, (pANTLR3_UINT8)"id:")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT(" "))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)" ")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_field_offset == NULL ? NULL : stream_field_offset->nextTree(stream_field_offset));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, WS, TOKTEXT("\n\t"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WS, (pANTLR3_UINT8)"\n\t")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_CLOSE, TOKTEXT("}"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_CLOSE, (pANTLR3_UINT8)"}")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {
                 
                        if ((	(SCOPE_TOP(field))->isRepeated||	(SCOPE_TOP(field))->isRequired)&&	(SCOPE_TOP(field))->defaultValue&&	(SCOPE_TOP(field))->defaultValue->len) {
                           fprintf(stderr,"error: line %d: default not allowed for repeated or optional elements in field %s : %s\n",(ITEM_TERMINATOR117->getLine(ITEM_TERMINATOR117)),	(SCOPE_TOP(field))->fieldName->chars,	(SCOPE_TOP(field))->defaultValue->chars);
                        }
                        defineField(ctx, 	(SCOPE_TOP(field))->fieldType,	(SCOPE_TOP(field))->fieldName,	(SCOPE_TOP(field))->defaultValue,	(SCOPE_TOP(field))->fieldOffset,	(SCOPE_TOP(field))->isRepeated==0,	(SCOPE_TOP(field))->isRequired,0);
                        stringFree(	(SCOPE_TOP(field))->fieldName);
                        stringFree(	(SCOPE_TOP(field))->fieldType);
                        stringFree(	(SCOPE_TOP(field))->defaultValue);
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefieldEx; /* Prevent compiler warnings */
    rulefieldEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EQUALS != NULL) stream_EQUALS->free(stream_EQUALS);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_field_name != NULL) stream_field_name->free(stream_field_name);
        if (stream_field_type != NULL) stream_field_type->free(stream_field_type);
        if (stream_field_offset != NULL) stream_field_offset->free(stream_field_offset);
        if (stream_default_value != NULL) stream_default_value->free(stream_default_value);
        if (stream_none != NULL) stream_none->free(stream_none);
        if (stream_multiplicitive_type != NULL) stream_multiplicitive_type->free(stream_multiplicitive_type);
        if (stream_multiplicity != NULL) stream_multiplicity->free(stream_multiplicity);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_fieldPop(ctx);

    return retval;
}
/* $ANTLR end field */

/** 
 * $ANTLR start multiplicity
 * ProtoJS.g:338:1: multiplicity : ( ( ProtoJSOPTIONAL ) | ( REQUIRED ) | ( REPEATED ) );
 */
static ProtoJSParser_multiplicity_return
multiplicity(pProtoJSParser ctx)
{   
    ProtoJSParser_multiplicity_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ProtoJSOPTIONAL118;
    pANTLR3_COMMON_TOKEN    REQUIRED119;
    pANTLR3_COMMON_TOKEN    REPEATED120;

    pANTLR3_BASE_TREE ProtoJSOPTIONAL118_tree;
    pANTLR3_BASE_TREE REQUIRED119_tree;
    pANTLR3_BASE_TREE REPEATED120_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    ProtoJSOPTIONAL118       = NULL;
    REQUIRED119       = NULL;
    REPEATED120       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    ProtoJSOPTIONAL118_tree   = NULL;
    REQUIRED119_tree   = NULL;
    REPEATED120_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:338:14: ( ( ProtoJSOPTIONAL ) | ( REQUIRED ) | ( REPEATED ) )
            
            ANTLR3_UINT32 alt20;

            alt20=3;

            switch ( LA(1) ) 
            {
            case ProtoJSOPTIONAL:
            	{
            		alt20=1;
            	}
                break;
            case REQUIRED:
            	{
            		alt20=2;
            	}
                break;
            case REPEATED:
            	{
            		alt20=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulemultiplicityEx;
            }

            switch (alt20) 
            {
        	case 1:
        	    // ProtoJS.g:338:16: ( ProtoJSOPTIONAL )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // ProtoJS.g:338:16: ( ProtoJSOPTIONAL )
        	        // ProtoJS.g:338:17: ProtoJSOPTIONAL
        	        {
        	            ProtoJSOPTIONAL118 = (pANTLR3_COMMON_TOKEN) MATCHT(ProtoJSOPTIONAL, &FOLLOW_ProtoJSOPTIONAL_in_multiplicity1885); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemultiplicityEx;
        	            }

        	            ProtoJSOPTIONAL118_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ProtoJSOPTIONAL118));
        	            ADAPTOR->addChild(ADAPTOR, root_0, ProtoJSOPTIONAL118_tree);


        	        }

        	        {
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:339:6: ( REQUIRED )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // ProtoJS.g:339:6: ( REQUIRED )
        	        // ProtoJS.g:339:7: REQUIRED
        	        {
        	            REQUIRED119 = (pANTLR3_COMMON_TOKEN) MATCHT(REQUIRED, &FOLLOW_REQUIRED_in_multiplicity1895); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemultiplicityEx;
        	            }

        	            REQUIRED119_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REQUIRED119));
        	            ADAPTOR->addChild(ADAPTOR, root_0, REQUIRED119_tree);


        	        }

        	        {
        	             	(SCOPE_TOP(field))->isRequired=1;
        	        }

        	    }
        	    break;
        	case 3:
        	    // ProtoJS.g:341:17: ( REPEATED )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        // ProtoJS.g:341:17: ( REPEATED )
        	        // ProtoJS.g:341:18: REPEATED
        	        {
        	            REPEATED120 = (pANTLR3_COMMON_TOKEN) MATCHT(REPEATED, &FOLLOW_REPEATED_in_multiplicity1923); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulemultiplicityEx;
        	            }

        	            REPEATED120_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REPEATED120));
        	            ADAPTOR->addChild(ADAPTOR, root_0, REPEATED120_tree);


        	        }

        	        {

        	                        	(SCOPE_TOP(field))->isRepeated=1;
        	                
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemultiplicityEx; /* Prevent compiler warnings */
    rulemultiplicityEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end multiplicity */

/** 
 * $ANTLR start none
 * ProtoJS.g:348:1: none : ( ( DOT )? ) -> IDENTIFIER[($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ?\"{packed:true}\":\"{}\"] ;
 */
static ProtoJSParser_none_return
none(pProtoJSParser ctx)
{   
    ProtoJSParser_none_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT121;

    pANTLR3_BASE_TREE DOT121_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DOT;

    /* Initialize rule variables
     */


    root_0 = NULL;

    DOT121       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    DOT121_tree   = NULL;

    stream_DOT   = NULL;
    #define CREATE_stream_DOT  if (stream_DOT == NULL) {stream_DOT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DOT"); } 

    retval.tree  = NULL;
    {
        // ProtoJS.g:348:6: ( ( ( DOT )? ) -> IDENTIFIER[($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ?\"{packed:true}\":\"{}\"] )
        // ProtoJS.g:348:8: ( ( DOT )? )
        {
            // ProtoJS.g:348:8: ( ( DOT )? )
            // ProtoJS.g:348:9: ( DOT )?
            {

                // ProtoJS.g:348:9: ( DOT )?
                {
                    int alt21=2;
                    switch ( LA(1) ) 
                    {
                        case DOT:
                        	{
                        		alt21=1;
                        	}
                            break;
                    }

                    switch (alt21) 
                    {
                	case 1:
                	    // ProtoJS.g:348:9: DOT
                	    {
                	        DOT121 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_none1943); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulenoneEx;
                	        }
                	         
                	        CREATE_stream_DOT; stream_DOT->add(stream_DOT, DOT121, NULL);


                	    }
                	    break;

                    }
                }

            }


             
            /* AST REWRITE
             * elements          : 
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 348:14: -> IDENTIFIER[($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ?\"{packed:true}\":\"{}\"]
            	{
            	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	    #if 1 == 2
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT((	(SCOPE_TOP(field))->isNumericType||isPackable(ctx,	(SCOPE_TOP(field))->fieldType))&&	(SCOPE_TOP(field))->isRepeated&&	(SCOPE_TOP(NameSpace))->isPBJ?"{packed:true}":"{}"))
            	    #else
            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)(	(SCOPE_TOP(field))->isNumericType||isPackable(ctx,	(SCOPE_TOP(field))->fieldType))&&	(SCOPE_TOP(field))->isRepeated&&	(SCOPE_TOP(NameSpace))->isPBJ?"{packed:true}":"{}")
            	    #endif
            	    );

            	}

            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenoneEx; /* Prevent compiler warnings */
    rulenoneEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_DOT != NULL) stream_DOT->free(stream_DOT);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end none */

/** 
 * $ANTLR start field_offset
 * ProtoJS.g:349:1: field_offset : integer ;
 */
static ProtoJSParser_field_offset_return
field_offset(pProtoJSParser ctx)
{   
    ProtoJSParser_field_offset_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_integer_return integer122;
    #undef	RETURN_TYPE_integer122
    #define	RETURN_TYPE_integer122 ProtoJSParser_integer_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    integer122.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:350:5: ( integer )
        // ProtoJS.g:350:7: integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_integer_in_field_offset1960);
            integer122=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefield_offsetEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, integer122.tree);
            {

                        
                        	(SCOPE_TOP(field))->fieldOffset=atoi((char*)((STRSTREAM->toStringTT(STRSTREAM, integer122.start, integer122.stop))->chars));
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefield_offsetEx; /* Prevent compiler warnings */
    rulefield_offsetEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end field_offset */

/** 
 * $ANTLR start field_name
 * ProtoJS.g:357:1: field_name : IDENTIFIER ;
 */
static ProtoJSParser_field_name_return
field_name(pProtoJSParser ctx)
{   
    ProtoJSParser_field_name_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER123;

    pANTLR3_BASE_TREE IDENTIFIER123_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER123       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER123_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:358:5: ( IDENTIFIER )
        // ProtoJS.g:358:7: IDENTIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            IDENTIFIER123 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_field_name1983); 
            if  (HASEXCEPTION())
            {
                goto rulefield_nameEx;
            }

            IDENTIFIER123_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER123));
            ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER123_tree);

            {

                        	(SCOPE_TOP(field))->fieldName=stringDup((IDENTIFIER123->getText(IDENTIFIER123)));
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefield_nameEx; /* Prevent compiler warnings */
    rulefield_nameEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end field_name */

/** 
 * $ANTLR start field_type
 * ProtoJS.g:364:1: field_type : ( ( numeric_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] numeric_type ) | ( floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] FLOAT[\"Float\"] ) | ( double_floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] DOUBLE[\"Double\"] ) | ( array_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] array_type ) | ( advanced_numeric_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_numeric_type ) | ( advanced_array_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_array_type ) | ( type_identifier -> QUALIFIEDIDENTIFIER[qualifyType( ctx, $type_identifier.text, $type_identifier.text )] ) );
 */
static ProtoJSParser_field_type_return
field_type(pProtoJSParser ctx)
{   
    ProtoJSParser_field_type_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_numeric_type_return numeric_type124;
    #undef	RETURN_TYPE_numeric_type124
    #define	RETURN_TYPE_numeric_type124 ProtoJSParser_numeric_type_return

    ProtoJSParser_floating_point_type_return floating_point_type125;
    #undef	RETURN_TYPE_floating_point_type125
    #define	RETURN_TYPE_floating_point_type125 ProtoJSParser_floating_point_type_return

    ProtoJSParser_double_floating_point_type_return double_floating_point_type126;
    #undef	RETURN_TYPE_double_floating_point_type126
    #define	RETURN_TYPE_double_floating_point_type126 ProtoJSParser_double_floating_point_type_return

    ProtoJSParser_array_type_return array_type127;
    #undef	RETURN_TYPE_array_type127
    #define	RETURN_TYPE_array_type127 ProtoJSParser_array_type_return

    ProtoJSParser_advanced_numeric_type_return advanced_numeric_type128;
    #undef	RETURN_TYPE_advanced_numeric_type128
    #define	RETURN_TYPE_advanced_numeric_type128 ProtoJSParser_advanced_numeric_type_return

    ProtoJSParser_advanced_array_type_return advanced_array_type129;
    #undef	RETURN_TYPE_advanced_array_type129
    #define	RETURN_TYPE_advanced_array_type129 ProtoJSParser_advanced_array_type_return

    ProtoJSParser_type_identifier_return type_identifier130;
    #undef	RETURN_TYPE_type_identifier130
    #define	RETURN_TYPE_type_identifier130 ProtoJSParser_type_identifier_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_numeric_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_advanced_array_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_advanced_numeric_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type_identifier;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_array_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_double_floating_point_type;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_floating_point_type;
    /* Initialize rule variables
     */


    root_0 = NULL;

    numeric_type124.tree = NULL;

    floating_point_type125.tree = NULL;

    double_floating_point_type126.tree = NULL;

    array_type127.tree = NULL;

    advanced_numeric_type128.tree = NULL;

    advanced_array_type129.tree = NULL;

    type_identifier130.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_numeric_type   = NULL;
    #define CREATE_stream_numeric_type  if (stream_numeric_type == NULL) {stream_numeric_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule numeric_type"); }
    stream_advanced_array_type   = NULL;
    #define CREATE_stream_advanced_array_type  if (stream_advanced_array_type == NULL) {stream_advanced_array_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule advanced_array_type"); }
    stream_advanced_numeric_type   = NULL;
    #define CREATE_stream_advanced_numeric_type  if (stream_advanced_numeric_type == NULL) {stream_advanced_numeric_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule advanced_numeric_type"); }
    stream_type_identifier   = NULL;
    #define CREATE_stream_type_identifier  if (stream_type_identifier == NULL) {stream_type_identifier = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule type_identifier"); }
    stream_array_type   = NULL;
    #define CREATE_stream_array_type  if (stream_array_type == NULL) {stream_array_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule array_type"); }
    stream_double_floating_point_type   = NULL;
    #define CREATE_stream_double_floating_point_type  if (stream_double_floating_point_type == NULL) {stream_double_floating_point_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule double_floating_point_type"); }
    stream_floating_point_type   = NULL;
    #define CREATE_stream_floating_point_type  if (stream_floating_point_type == NULL) {stream_floating_point_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule floating_point_type"); }

    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:365:5: ( ( numeric_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] numeric_type ) | ( floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] FLOAT[\"Float\"] ) | ( double_floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] DOUBLE[\"Double\"] ) | ( array_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] array_type ) | ( advanced_numeric_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_numeric_type ) | ( advanced_array_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_array_type ) | ( type_identifier -> QUALIFIEDIDENTIFIER[qualifyType( ctx, $type_identifier.text, $type_identifier.text )] ) )
            
            ANTLR3_UINT32 alt22;

            alt22=7;

            switch ( LA(1) ) 
            {
            case UINT32:
            case INT32:
            case SINT32:
            case FIXED32:
            case SFIXED32:
            case UINT64:
            case INT64:
            case SINT64:
            case FIXED64:
            case SFIXED64:
            case BOOL:
            	{
            		alt22=1;
            	}
                break;
            case FLOAT:
            	{
            		alt22=2;
            	}
                break;
            case DOUBLE:
            	{
            		alt22=3;
            	}
                break;
            case STRING:
            case BYTES:
            	{
            		alt22=4;
            	}
                break;
            case UINT8:
            case INT8:
            case SINT8:
            case FIXED8:
            case SFIXED8:
            case INT16:
            case SINT16:
            case FIXED16:
            case SFIXED16:
            case UINT16:
            case ANGLE:
            case TIME:
            case DURATION:
            	{
            		alt22=5;
            	}
                break;
            case UUID:
            case SHA256:
            	{
            		alt22=6;
            	}
                break;
            case QUALIFIEDIDENTIFIER:
            case IDENTIFIER:
            	{
            		alt22=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulefield_typeEx;
            }

            switch (alt22) 
            {
        	case 1:
        	    // ProtoJS.g:365:7: ( numeric_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] numeric_type )
        	    {
        	        // ProtoJS.g:365:7: ( numeric_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] numeric_type )
        	        // ProtoJS.g:365:8: numeric_type
        	        {
        	            FOLLOWPUSH(FOLLOW_numeric_type_in_field_type2007);
        	            numeric_type124=numeric_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_numeric_type; stream_numeric_type->add(stream_numeric_type, numeric_type124.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : numeric_type
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 365:21: -> QUALIFIEDIDENTIFIER[\"PROTO.\"] numeric_type
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_numeric_type == NULL ? NULL : stream_numeric_type->nextTree(stream_numeric_type));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                    	(SCOPE_TOP(field))->isNumericType=1;
        	                    	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, numeric_type124.start, numeric_type124.stop)));
        	                
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:370:7: ( floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] FLOAT[\"Float\"] )
        	    {
        	        // ProtoJS.g:370:7: ( floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] FLOAT[\"Float\"] )
        	        // ProtoJS.g:370:8: floating_point_type
        	        {
        	            FOLLOWPUSH(FOLLOW_floating_point_type_in_field_type2029);
        	            floating_point_type125=floating_point_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_floating_point_type; stream_floating_point_type->add(stream_floating_point_type, floating_point_type125.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : 
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 370:28: -> QUALIFIEDIDENTIFIER[\"PROTO.\"] FLOAT[\"Float\"]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, FLOAT, TOKTEXT("Float"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FLOAT, (pANTLR3_UINT8)"Float")
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                    	(SCOPE_TOP(field))->isNumericType=1;
        	                    	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, floating_point_type125.start, floating_point_type125.stop)));
        	                    	(SCOPE_TOP(field))->fieldType->set8(	(SCOPE_TOP(field))->fieldType,"Float");
        	                
        	        }

        	    }
        	    break;
        	case 3:
        	    // ProtoJS.g:376:7: ( double_floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] DOUBLE[\"Double\"] )
        	    {
        	        // ProtoJS.g:376:7: ( double_floating_point_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] DOUBLE[\"Double\"] )
        	        // ProtoJS.g:376:8: double_floating_point_type
        	        {
        	            FOLLOWPUSH(FOLLOW_double_floating_point_type_in_field_type2053);
        	            double_floating_point_type126=double_floating_point_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_double_floating_point_type; stream_double_floating_point_type->add(stream_double_floating_point_type, double_floating_point_type126.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : 
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 376:35: -> QUALIFIEDIDENTIFIER[\"PROTO.\"] DOUBLE[\"Double\"]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, DOUBLE, TOKTEXT("Double"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DOUBLE, (pANTLR3_UINT8)"Double")
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                    	(SCOPE_TOP(field))->isNumericType=1;
        	                    	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, double_floating_point_type126.start, double_floating_point_type126.stop)));
        	                    	(SCOPE_TOP(field))->fieldType->set8(	(SCOPE_TOP(field))->fieldType,"Double");
        	                
        	        }

        	    }
        	    break;
        	case 4:
        	    // ProtoJS.g:382:7: ( array_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] array_type )
        	    {
        	        // ProtoJS.g:382:7: ( array_type -> QUALIFIEDIDENTIFIER[\"PROTO.\"] array_type )
        	        // ProtoJS.g:382:8: array_type
        	        {
        	            FOLLOWPUSH(FOLLOW_array_type_in_field_type2077);
        	            array_type127=array_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_array_type; stream_array_type->add(stream_array_type, array_type127.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : array_type
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 382:19: -> QUALIFIEDIDENTIFIER[\"PROTO.\"] array_type
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PROTO."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PROTO.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_array_type == NULL ? NULL : stream_array_type->nextTree(stream_array_type));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                    	(SCOPE_TOP(field))->isNumericType=0;
        	                    	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, array_type127.start, array_type127.stop)));
        	                
        	        }

        	    }
        	    break;
        	case 5:
        	    // ProtoJS.g:387:7: ( advanced_numeric_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_numeric_type )
        	    {
        	        // ProtoJS.g:387:7: ( advanced_numeric_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_numeric_type )
        	        // ProtoJS.g:387:8: advanced_numeric_type
        	        {
        	            FOLLOWPUSH(FOLLOW_advanced_numeric_type_in_field_type2100);
        	            advanced_numeric_type128=advanced_numeric_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_advanced_numeric_type; stream_advanced_numeric_type->add(stream_advanced_numeric_type, advanced_numeric_type128.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : advanced_numeric_type
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 387:30: -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_numeric_type
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PBJ."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PBJ.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_advanced_numeric_type == NULL ? NULL : stream_advanced_numeric_type->nextTree(stream_advanced_numeric_type));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                   	(SCOPE_TOP(field))->isNumericType=1;
        	                   	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, advanced_numeric_type128.start, advanced_numeric_type128.stop)));
        	                
        	        }

        	    }
        	    break;
        	case 6:
        	    // ProtoJS.g:392:7: ( advanced_array_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_array_type )
        	    {
        	        // ProtoJS.g:392:7: ( advanced_array_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_array_type )
        	        // ProtoJS.g:392:8: advanced_array_type
        	        {
        	            FOLLOWPUSH(FOLLOW_advanced_array_type_in_field_type2123);
        	            advanced_array_type129=advanced_array_type(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_advanced_array_type; stream_advanced_array_type->add(stream_advanced_array_type, advanced_array_type129.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : advanced_array_type
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 392:28: -> QUALIFIEDIDENTIFIER[\"PBJ.\"] advanced_array_type
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PBJ."))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PBJ.")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_advanced_array_type == NULL ? NULL : stream_advanced_array_type->nextTree(stream_advanced_array_type));

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                   	(SCOPE_TOP(field))->isNumericType=0;
        	                   	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, advanced_array_type129.start, advanced_array_type129.stop)));
        	                
        	        }

        	    }
        	    break;
        	case 7:
        	    // ProtoJS.g:397:7: ( type_identifier -> QUALIFIEDIDENTIFIER[qualifyType( ctx, $type_identifier.text, $type_identifier.text )] )
        	    {
        	        // ProtoJS.g:397:7: ( type_identifier -> QUALIFIEDIDENTIFIER[qualifyType( ctx, $type_identifier.text, $type_identifier.text )] )
        	        // ProtoJS.g:397:9: type_identifier
        	        {
        	            FOLLOWPUSH(FOLLOW_type_identifier_in_field_type2147);
        	            type_identifier130=type_identifier(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulefield_typeEx;
        	            }

        	            CREATE_stream_type_identifier; stream_type_identifier->add(stream_type_identifier, type_identifier130.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : 
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 397:25: -> QUALIFIEDIDENTIFIER[qualifyType( ctx, $type_identifier.text, $type_identifier.text )]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT(qualifyType( ctx, (STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)), (STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)) )))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)qualifyType( ctx, (STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)), (STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)) ))
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                   	(SCOPE_TOP(field))->isNumericType=(isEnum(ctx,(STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)))||
        	                                          isFlag(ctx,(STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop))));
        	                   	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, type_identifier130.start, type_identifier130.stop)));
        	                
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulefield_typeEx; /* Prevent compiler warnings */
    rulefield_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_numeric_type != NULL) stream_numeric_type->free(stream_numeric_type);
        if (stream_advanced_array_type != NULL) stream_advanced_array_type->free(stream_advanced_array_type);
        if (stream_advanced_numeric_type != NULL) stream_advanced_numeric_type->free(stream_advanced_numeric_type);
        if (stream_type_identifier != NULL) stream_type_identifier->free(stream_type_identifier);
        if (stream_array_type != NULL) stream_array_type->free(stream_array_type);
        if (stream_double_floating_point_type != NULL) stream_double_floating_point_type->free(stream_double_floating_point_type);
        if (stream_floating_point_type != NULL) stream_floating_point_type->free(stream_floating_point_type);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end field_type */

/** 
 * $ANTLR start type_identifier
 * ProtoJS.g:405:1: type_identifier : ( IDENTIFIER | QUALIFIEDIDENTIFIER );
 */
static ProtoJSParser_type_identifier_return
type_identifier(pProtoJSParser ctx)
{   
    ProtoJSParser_type_identifier_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set131;

    pANTLR3_BASE_TREE set131_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set131       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set131_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:406:5: ( IDENTIFIER | QUALIFIEDIDENTIFIER )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set131=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= QUALIFIEDIDENTIFIER) && (LA(1) <= IDENTIFIER)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set131)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_type_identifier0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_type_identifier0);    goto ruletype_identifierEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletype_identifierEx; /* Prevent compiler warnings */
    ruletype_identifierEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end type_identifier */

/** 
 * $ANTLR start multiplicitive_type
 * ProtoJS.g:408:1: multiplicitive_type : ( multiplicitive_advanced_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] multiplicitive_advanced_type ) ;
 */
static ProtoJSParser_multiplicitive_type_return
multiplicitive_type(pProtoJSParser ctx)
{   
    ProtoJSParser_multiplicitive_type_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_multiplicitive_advanced_type_return multiplicitive_advanced_type132;
    #undef	RETURN_TYPE_multiplicitive_advanced_type132
    #define	RETURN_TYPE_multiplicitive_advanced_type132 ProtoJSParser_multiplicitive_advanced_type_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_multiplicitive_advanced_type;
    /* Initialize rule variables
     */


    root_0 = NULL;

    multiplicitive_advanced_type132.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;


    stream_multiplicitive_advanced_type   = NULL;
    #define CREATE_stream_multiplicitive_advanced_type  if (stream_multiplicitive_advanced_type == NULL) {stream_multiplicitive_advanced_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule multiplicitive_advanced_type"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:409:5: ( ( multiplicitive_advanced_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] multiplicitive_advanced_type ) )
        // ProtoJS.g:410:5: ( multiplicitive_advanced_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] multiplicitive_advanced_type )
        {
            // ProtoJS.g:410:5: ( multiplicitive_advanced_type -> QUALIFIEDIDENTIFIER[\"PBJ.\"] multiplicitive_advanced_type )
            // ProtoJS.g:410:6: multiplicitive_advanced_type
            {
                FOLLOWPUSH(FOLLOW_multiplicitive_advanced_type_in_multiplicitive_type2204);
                multiplicitive_advanced_type132=multiplicitive_advanced_type(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulemultiplicitive_typeEx;
                }

                CREATE_stream_multiplicitive_advanced_type; stream_multiplicitive_advanced_type->add(stream_multiplicitive_advanced_type, multiplicitive_advanced_type132.tree, NULL);

                 
                /* AST REWRITE
                 * elements          : multiplicitive_advanced_type
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 410:35: -> QUALIFIEDIDENTIFIER[\"PBJ.\"] multiplicitive_advanced_type
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, QUALIFIEDIDENTIFIER, TOKTEXT("PBJ."))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, QUALIFIEDIDENTIFIER, (pANTLR3_UINT8)"PBJ.")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_multiplicitive_advanced_type == NULL ? NULL : stream_multiplicitive_advanced_type->nextTree(stream_multiplicitive_advanced_type));

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                       	(SCOPE_TOP(field))->fieldType=stringDup((STRSTREAM->toStringTT(STRSTREAM, multiplicitive_advanced_type132.start, multiplicitive_advanced_type132.stop)));
                       	(SCOPE_TOP(field))->isNumericType=1;
                       	(SCOPE_TOP(field))->isRepeated=1;
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemultiplicitive_typeEx; /* Prevent compiler warnings */
    rulemultiplicitive_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_multiplicitive_advanced_type != NULL) stream_multiplicitive_advanced_type->free(stream_multiplicitive_advanced_type);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end multiplicitive_type */

/** 
 * $ANTLR start array_spec
 * ProtoJS.g:418:1: array_spec : SQBRACKET_OPEN ( integer )? SQBRACKET_CLOSE ;
 */
static ProtoJSParser_array_spec_return
array_spec(pProtoJSParser ctx)
{   
    ProtoJSParser_array_spec_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SQBRACKET_OPEN133;
    pANTLR3_COMMON_TOKEN    SQBRACKET_CLOSE135;
    ProtoJSParser_integer_return integer134;
    #undef	RETURN_TYPE_integer134
    #define	RETURN_TYPE_integer134 ProtoJSParser_integer_return

    pANTLR3_BASE_TREE SQBRACKET_OPEN133_tree;
    pANTLR3_BASE_TREE SQBRACKET_CLOSE135_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    SQBRACKET_OPEN133       = NULL;
    SQBRACKET_CLOSE135       = NULL;
    integer134.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SQBRACKET_OPEN133_tree   = NULL;
    SQBRACKET_CLOSE135_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:419:2: ( SQBRACKET_OPEN ( integer )? SQBRACKET_CLOSE )
        // ProtoJS.g:419:4: SQBRACKET_OPEN ( integer )? SQBRACKET_CLOSE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            SQBRACKET_OPEN133 = (pANTLR3_COMMON_TOKEN) MATCHT(SQBRACKET_OPEN, &FOLLOW_SQBRACKET_OPEN_in_array_spec2232); 
            if  (HASEXCEPTION())
            {
                goto rulearray_specEx;
            }

            SQBRACKET_OPEN133_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SQBRACKET_OPEN133));
            ADAPTOR->addChild(ADAPTOR, root_0, SQBRACKET_OPEN133_tree);


            // ProtoJS.g:419:19: ( integer )?
            {
                int alt23=2;
                switch ( LA(1) ) 
                {
                    case HEX_LITERAL:
                    case DECIMAL_LITERAL:
                    case OCTAL_LITERAL:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23) 
                {
            	case 1:
            	    // ProtoJS.g:419:19: integer
            	    {
            	        FOLLOWPUSH(FOLLOW_integer_in_array_spec2234);
            	        integer134=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulearray_specEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, integer134.tree);

            	    }
            	    break;

                }
            }
            SQBRACKET_CLOSE135 = (pANTLR3_COMMON_TOKEN) MATCHT(SQBRACKET_CLOSE, &FOLLOW_SQBRACKET_CLOSE_in_array_spec2237); 
            if  (HASEXCEPTION())
            {
                goto rulearray_specEx;
            }

            SQBRACKET_CLOSE135_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SQBRACKET_CLOSE135));
            ADAPTOR->addChild(ADAPTOR, root_0, SQBRACKET_CLOSE135_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulearray_specEx; /* Prevent compiler warnings */
    rulearray_specEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end array_spec */

/** 
 * $ANTLR start option_assignment
 * ProtoJS.g:421:1: option_assignment : ( OPTION_LITERAL ( PAREN_OPEN )? IDENTIFIER ( PAREN_CLOSE )? EQUALS option_assignment_value ITEM_TERMINATOR ->) ;
 */
static ProtoJSParser_option_assignment_return
option_assignment(pProtoJSParser ctx)
{   
    ProtoJSParser_option_assignment_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OPTION_LITERAL136;
    pANTLR3_COMMON_TOKEN    PAREN_OPEN137;
    pANTLR3_COMMON_TOKEN    IDENTIFIER138;
    pANTLR3_COMMON_TOKEN    PAREN_CLOSE139;
    pANTLR3_COMMON_TOKEN    EQUALS140;
    pANTLR3_COMMON_TOKEN    ITEM_TERMINATOR142;
    ProtoJSParser_option_assignment_value_return option_assignment_value141;
    #undef	RETURN_TYPE_option_assignment_value141
    #define	RETURN_TYPE_option_assignment_value141 ProtoJSParser_option_assignment_value_return

    pANTLR3_BASE_TREE OPTION_LITERAL136_tree;
    pANTLR3_BASE_TREE PAREN_OPEN137_tree;
    pANTLR3_BASE_TREE IDENTIFIER138_tree;
    pANTLR3_BASE_TREE PAREN_CLOSE139_tree;
    pANTLR3_BASE_TREE EQUALS140_tree;
    pANTLR3_BASE_TREE ITEM_TERMINATOR142_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_OPTION_LITERAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUALS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PAREN_OPEN;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PAREN_CLOSE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ITEM_TERMINATOR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_option_assignment_value;
    /* Initialize rule variables
     */


    root_0 = NULL;

    OPTION_LITERAL136       = NULL;
    PAREN_OPEN137       = NULL;
    IDENTIFIER138       = NULL;
    PAREN_CLOSE139       = NULL;
    EQUALS140       = NULL;
    ITEM_TERMINATOR142       = NULL;
    option_assignment_value141.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OPTION_LITERAL136_tree   = NULL;
    PAREN_OPEN137_tree   = NULL;
    IDENTIFIER138_tree   = NULL;
    PAREN_CLOSE139_tree   = NULL;
    EQUALS140_tree   = NULL;
    ITEM_TERMINATOR142_tree   = NULL;

    stream_OPTION_LITERAL   = NULL;
    #define CREATE_stream_OPTION_LITERAL  if (stream_OPTION_LITERAL == NULL) {stream_OPTION_LITERAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token OPTION_LITERAL"); } 
    stream_EQUALS   = NULL;
    #define CREATE_stream_EQUALS  if (stream_EQUALS == NULL) {stream_EQUALS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUALS"); } 
    stream_PAREN_OPEN   = NULL;
    #define CREATE_stream_PAREN_OPEN  if (stream_PAREN_OPEN == NULL) {stream_PAREN_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PAREN_OPEN"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_PAREN_CLOSE   = NULL;
    #define CREATE_stream_PAREN_CLOSE  if (stream_PAREN_CLOSE == NULL) {stream_PAREN_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PAREN_CLOSE"); } 
    stream_ITEM_TERMINATOR   = NULL;
    #define CREATE_stream_ITEM_TERMINATOR  if (stream_ITEM_TERMINATOR == NULL) {stream_ITEM_TERMINATOR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ITEM_TERMINATOR"); } 
    stream_option_assignment_value   = NULL;
    #define CREATE_stream_option_assignment_value  if (stream_option_assignment_value == NULL) {stream_option_assignment_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule option_assignment_value"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:422:5: ( ( OPTION_LITERAL ( PAREN_OPEN )? IDENTIFIER ( PAREN_CLOSE )? EQUALS option_assignment_value ITEM_TERMINATOR ->) )
        // ProtoJS.g:423:5: ( OPTION_LITERAL ( PAREN_OPEN )? IDENTIFIER ( PAREN_CLOSE )? EQUALS option_assignment_value ITEM_TERMINATOR ->)
        {
            // ProtoJS.g:423:5: ( OPTION_LITERAL ( PAREN_OPEN )? IDENTIFIER ( PAREN_CLOSE )? EQUALS option_assignment_value ITEM_TERMINATOR ->)
            // ProtoJS.g:423:6: OPTION_LITERAL ( PAREN_OPEN )? IDENTIFIER ( PAREN_CLOSE )? EQUALS option_assignment_value ITEM_TERMINATOR
            {
                OPTION_LITERAL136 = (pANTLR3_COMMON_TOKEN) MATCHT(OPTION_LITERAL, &FOLLOW_OPTION_LITERAL_in_option_assignment2255); 
                if  (HASEXCEPTION())
                {
                    goto ruleoption_assignmentEx;
                }
                 
                CREATE_stream_OPTION_LITERAL; stream_OPTION_LITERAL->add(stream_OPTION_LITERAL, OPTION_LITERAL136, NULL);


                // ProtoJS.g:423:21: ( PAREN_OPEN )?
                {
                    int alt24=2;
                    switch ( LA(1) ) 
                    {
                        case PAREN_OPEN:
                        	{
                        		alt24=1;
                        	}
                            break;
                    }

                    switch (alt24) 
                    {
                	case 1:
                	    // ProtoJS.g:423:21: PAREN_OPEN
                	    {
                	        PAREN_OPEN137 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_OPEN, &FOLLOW_PAREN_OPEN_in_option_assignment2257); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleoption_assignmentEx;
                	        }
                	         
                	        CREATE_stream_PAREN_OPEN; stream_PAREN_OPEN->add(stream_PAREN_OPEN, PAREN_OPEN137, NULL);


                	    }
                	    break;

                    }
                }
                IDENTIFIER138 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_option_assignment2260); 
                if  (HASEXCEPTION())
                {
                    goto ruleoption_assignmentEx;
                }
                 
                CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER138, NULL);


                // ProtoJS.g:423:44: ( PAREN_CLOSE )?
                {
                    int alt25=2;
                    switch ( LA(1) ) 
                    {
                        case PAREN_CLOSE:
                        	{
                        		alt25=1;
                        	}
                            break;
                    }

                    switch (alt25) 
                    {
                	case 1:
                	    // ProtoJS.g:423:44: PAREN_CLOSE
                	    {
                	        PAREN_CLOSE139 = (pANTLR3_COMMON_TOKEN) MATCHT(PAREN_CLOSE, &FOLLOW_PAREN_CLOSE_in_option_assignment2262); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleoption_assignmentEx;
                	        }
                	         
                	        CREATE_stream_PAREN_CLOSE; stream_PAREN_CLOSE->add(stream_PAREN_CLOSE, PAREN_CLOSE139, NULL);


                	    }
                	    break;

                    }
                }
                EQUALS140 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_option_assignment2265); 
                if  (HASEXCEPTION())
                {
                    goto ruleoption_assignmentEx;
                }
                 
                CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS140, NULL);

                FOLLOWPUSH(FOLLOW_option_assignment_value_in_option_assignment2267);
                option_assignment_value141=option_assignment_value(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleoption_assignmentEx;
                }

                CREATE_stream_option_assignment_value; stream_option_assignment_value->add(stream_option_assignment_value, option_assignment_value141.tree, NULL);
                ITEM_TERMINATOR142 = (pANTLR3_COMMON_TOKEN) MATCHT(ITEM_TERMINATOR, &FOLLOW_ITEM_TERMINATOR_in_option_assignment2269); 
                if  (HASEXCEPTION())
                {
                    goto ruleoption_assignmentEx;
                }
                 
                CREATE_stream_ITEM_TERMINATOR; stream_ITEM_TERMINATOR->add(stream_ITEM_TERMINATOR, ITEM_TERMINATOR142, NULL);


                 
                /* AST REWRITE
                 * elements          : 
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 423:104: ->
                	{
                	    root_0 = NULL; /* <-- rewriteEmptyAlt()) */
                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }

            {

                            if (strcmp((IDENTIFIER138->getText(IDENTIFIER138))->chars,"java_package")!=0&&
                                strcmp((IDENTIFIER138->getText(IDENTIFIER138))->chars,"java_outer_classname")!=0&&
                                strcmp((IDENTIFIER138->getText(IDENTIFIER138))->chars,"java_multiple_files")!=0&&
                                strcmp((IDENTIFIER138->getText(IDENTIFIER138))->chars,"optimize_for")!=0) {
                                fprintf(stderr,"Warning: Unrecognized option %s\n",(IDENTIFIER138->getText(IDENTIFIER138))->chars);
                            }
                                
                    
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoption_assignmentEx; /* Prevent compiler warnings */
    ruleoption_assignmentEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_OPTION_LITERAL != NULL) stream_OPTION_LITERAL->free(stream_OPTION_LITERAL);
        if (stream_EQUALS != NULL) stream_EQUALS->free(stream_EQUALS);
        if (stream_PAREN_OPEN != NULL) stream_PAREN_OPEN->free(stream_PAREN_OPEN);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_PAREN_CLOSE != NULL) stream_PAREN_CLOSE->free(stream_PAREN_CLOSE);
        if (stream_ITEM_TERMINATOR != NULL) stream_ITEM_TERMINATOR->free(stream_ITEM_TERMINATOR);
        if (stream_option_assignment_value != NULL) stream_option_assignment_value->free(stream_option_assignment_value);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end option_assignment */

/** 
 * $ANTLR start option_assignment_value
 * ProtoJS.g:435:1: option_assignment_value : ( literal_value | QUALIFIEDIDENTIFIER | IDENTIFIER ) ;
 */
static ProtoJSParser_option_assignment_value_return
option_assignment_value(pProtoJSParser ctx)
{   
    ProtoJSParser_option_assignment_value_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    QUALIFIEDIDENTIFIER144;
    pANTLR3_COMMON_TOKEN    IDENTIFIER145;
    ProtoJSParser_literal_value_return literal_value143;
    #undef	RETURN_TYPE_literal_value143
    #define	RETURN_TYPE_literal_value143 ProtoJSParser_literal_value_return

    pANTLR3_BASE_TREE QUALIFIEDIDENTIFIER144_tree;
    pANTLR3_BASE_TREE IDENTIFIER145_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    QUALIFIEDIDENTIFIER144       = NULL;
    IDENTIFIER145       = NULL;
    literal_value143.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    QUALIFIEDIDENTIFIER144_tree   = NULL;
    IDENTIFIER145_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:435:24: ( ( literal_value | QUALIFIEDIDENTIFIER | IDENTIFIER ) )
        // ProtoJS.g:435:26: ( literal_value | QUALIFIEDIDENTIFIER | IDENTIFIER )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // ProtoJS.g:435:26: ( literal_value | QUALIFIEDIDENTIFIER | IDENTIFIER )
            {
                int alt26=3;
                switch ( LA(1) ) 
                {
                case STRING_LITERAL:
                case HEX_LITERAL:
                case DECIMAL_LITERAL:
                case OCTAL_LITERAL:
                case FLOATING_POINT_LITERAL:
                case BOOL_LITERAL:
                	{
                		alt26=1;
                	}
                    break;
                case QUALIFIEDIDENTIFIER:
                	{
                		alt26=2;
                	}
                    break;
                case IDENTIFIER:
                	{
                		alt26=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 26;
                    EXCEPTION->state        = 0;


                    goto ruleoption_assignment_valueEx;
                }

                switch (alt26) 
                {
            	case 1:
            	    // ProtoJS.g:435:27: literal_value
            	    {
            	        FOLLOWPUSH(FOLLOW_literal_value_in_option_assignment_value2292);
            	        literal_value143=literal_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoption_assignment_valueEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, literal_value143.tree);

            	    }
            	    break;
            	case 2:
            	    // ProtoJS.g:435:41: QUALIFIEDIDENTIFIER
            	    {
            	        QUALIFIEDIDENTIFIER144 = (pANTLR3_COMMON_TOKEN) MATCHT(QUALIFIEDIDENTIFIER, &FOLLOW_QUALIFIEDIDENTIFIER_in_option_assignment_value2294); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoption_assignment_valueEx;
            	        }

            	        QUALIFIEDIDENTIFIER144_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, QUALIFIEDIDENTIFIER144));
            	        ADAPTOR->addChild(ADAPTOR, root_0, QUALIFIEDIDENTIFIER144_tree);


            	    }
            	    break;
            	case 3:
            	    // ProtoJS.g:435:61: IDENTIFIER
            	    {
            	        IDENTIFIER145 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_option_assignment_value2296); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoption_assignment_valueEx;
            	        }

            	        IDENTIFIER145_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER145));
            	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER145_tree);


            	    }
            	    break;

                }
            }
            {
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoption_assignment_valueEx; /* Prevent compiler warnings */
    ruleoption_assignment_valueEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end option_assignment_value */

/** 
 * $ANTLR start default_value
 * ProtoJS.g:436:1: default_value : ( SQBRACKET_OPEN option_pairs SQBRACKET_CLOSE -> {($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ}? BLOCK_OPEN[\"{\"] option_pairs COMMA[\",\"] IDENTIFIER[\"packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] BLOCK_CLOSE[\"}\"] -> BLOCK_OPEN[\"{\"] option_pairs BLOCK_CLOSE[\"}\"] ) ;
 */
static ProtoJSParser_default_value_return
default_value(pProtoJSParser ctx)
{   
    ProtoJSParser_default_value_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SQBRACKET_OPEN146;
    pANTLR3_COMMON_TOKEN    SQBRACKET_CLOSE148;
    ProtoJSParser_option_pairs_return option_pairs147;
    #undef	RETURN_TYPE_option_pairs147
    #define	RETURN_TYPE_option_pairs147 ProtoJSParser_option_pairs_return

    pANTLR3_BASE_TREE SQBRACKET_OPEN146_tree;
    pANTLR3_BASE_TREE SQBRACKET_CLOSE148_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SQBRACKET_CLOSE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SQBRACKET_OPEN;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_option_pairs;
    /* Initialize rule variables
     */


    root_0 = NULL;

    SQBRACKET_OPEN146       = NULL;
    SQBRACKET_CLOSE148       = NULL;
    option_pairs147.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SQBRACKET_OPEN146_tree   = NULL;
    SQBRACKET_CLOSE148_tree   = NULL;

    stream_SQBRACKET_CLOSE   = NULL;
    #define CREATE_stream_SQBRACKET_CLOSE  if (stream_SQBRACKET_CLOSE == NULL) {stream_SQBRACKET_CLOSE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SQBRACKET_CLOSE"); } 
    stream_SQBRACKET_OPEN   = NULL;
    #define CREATE_stream_SQBRACKET_OPEN  if (stream_SQBRACKET_OPEN == NULL) {stream_SQBRACKET_OPEN = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SQBRACKET_OPEN"); } 
    stream_option_pairs   = NULL;
    #define CREATE_stream_option_pairs  if (stream_option_pairs == NULL) {stream_option_pairs = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule option_pairs"); }

    retval.tree  = NULL;
    {
        // ProtoJS.g:437:2: ( ( SQBRACKET_OPEN option_pairs SQBRACKET_CLOSE -> {($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ}? BLOCK_OPEN[\"{\"] option_pairs COMMA[\",\"] IDENTIFIER[\"packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] BLOCK_CLOSE[\"}\"] -> BLOCK_OPEN[\"{\"] option_pairs BLOCK_CLOSE[\"}\"] ) )
        // ProtoJS.g:438:5: ( SQBRACKET_OPEN option_pairs SQBRACKET_CLOSE -> {($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ}? BLOCK_OPEN[\"{\"] option_pairs COMMA[\",\"] IDENTIFIER[\"packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] BLOCK_CLOSE[\"}\"] -> BLOCK_OPEN[\"{\"] option_pairs BLOCK_CLOSE[\"}\"] )
        {
            // ProtoJS.g:438:5: ( SQBRACKET_OPEN option_pairs SQBRACKET_CLOSE -> {($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ}? BLOCK_OPEN[\"{\"] option_pairs COMMA[\",\"] IDENTIFIER[\"packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] BLOCK_CLOSE[\"}\"] -> BLOCK_OPEN[\"{\"] option_pairs BLOCK_CLOSE[\"}\"] )
            // ProtoJS.g:438:6: SQBRACKET_OPEN option_pairs SQBRACKET_CLOSE
            {
                SQBRACKET_OPEN146 = (pANTLR3_COMMON_TOKEN) MATCHT(SQBRACKET_OPEN, &FOLLOW_SQBRACKET_OPEN_in_default_value2313); 
                if  (HASEXCEPTION())
                {
                    goto ruledefault_valueEx;
                }
                 
                CREATE_stream_SQBRACKET_OPEN; stream_SQBRACKET_OPEN->add(stream_SQBRACKET_OPEN, SQBRACKET_OPEN146, NULL);

                FOLLOWPUSH(FOLLOW_option_pairs_in_default_value2315);
                option_pairs147=option_pairs(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruledefault_valueEx;
                }

                CREATE_stream_option_pairs; stream_option_pairs->add(stream_option_pairs, option_pairs147.tree, NULL);
                SQBRACKET_CLOSE148 = (pANTLR3_COMMON_TOKEN) MATCHT(SQBRACKET_CLOSE, &FOLLOW_SQBRACKET_CLOSE_in_default_value2317); 
                if  (HASEXCEPTION())
                {
                    goto ruledefault_valueEx;
                }
                 
                CREATE_stream_SQBRACKET_CLOSE; stream_SQBRACKET_CLOSE->add(stream_SQBRACKET_CLOSE, SQBRACKET_CLOSE148, NULL);


                 
                /* AST REWRITE
                 * elements          : option_pairs, option_pairs
                 * token labels      : 
                 * rule labels       : retval
                 * token list labels : 
                 * rule list labels  : 
                 */
                {
                	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

                	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

                	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                	retval.tree    = root_0;
                	// 438:50: -> {($field::isNumericType||isPackable(ctx,$field::fieldType))&&$field::isRepeated&&$NameSpace::isPBJ}? BLOCK_OPEN[\"{\"] option_pairs COMMA[\",\"] IDENTIFIER[\"packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] BLOCK_CLOSE[\"}\"]
                	if ((	(SCOPE_TOP(field))->isNumericType||isPackable(ctx,	(SCOPE_TOP(field))->fieldType))&&	(SCOPE_TOP(field))->isRepeated&&	(SCOPE_TOP(NameSpace))->isPBJ) 
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_OPEN, TOKTEXT("{"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_OPEN, (pANTLR3_UINT8)"{")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_option_pairs == NULL ? NULL : stream_option_pairs->nextTree(stream_option_pairs));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COMMA, TOKTEXT(","))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMMA, (pANTLR3_UINT8)",")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT("packed"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)"packed")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BOOL_LITERAL, TOKTEXT("true"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BOOL_LITERAL, (pANTLR3_UINT8)"true")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_CLOSE, TOKTEXT("}"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_CLOSE, (pANTLR3_UINT8)"}")
                	    #endif
                	    );

                	}
                	else // 440:6: -> BLOCK_OPEN[\"{\"] option_pairs BLOCK_CLOSE[\"}\"]
                	{
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_OPEN, TOKTEXT("{"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_OPEN, (pANTLR3_UINT8)"{")
                	    #endif
                	    );
                	    ADAPTOR->addChild(ADAPTOR, root_0, stream_option_pairs == NULL ? NULL : stream_option_pairs->nextTree(stream_option_pairs));
                	    ADAPTOR->addChild(ADAPTOR, root_0, 
                	    #if 1 == 2
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BLOCK_CLOSE, TOKTEXT("}"))
                	    #else
                	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BLOCK_CLOSE, (pANTLR3_UINT8)"}")
                	    #endif
                	    );

                	}

                	retval.tree = root_0; // set result root
                	if (stream_retval != NULL) stream_retval->free(stream_retval);


                }
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledefault_valueEx; /* Prevent compiler warnings */
    ruledefault_valueEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_SQBRACKET_CLOSE != NULL) stream_SQBRACKET_CLOSE->free(stream_SQBRACKET_CLOSE);
        if (stream_SQBRACKET_OPEN != NULL) stream_SQBRACKET_OPEN->free(stream_SQBRACKET_OPEN);
        if (stream_option_pairs != NULL) stream_option_pairs->free(stream_option_pairs);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end default_value */

/** 
 * $ANTLR start option_pairs
 * ProtoJS.g:443:1: option_pairs : option_pair ( COMMA option_pair )* ;
 */
static ProtoJSParser_option_pairs_return
option_pairs(pProtoJSParser ctx)
{   
    ProtoJSParser_option_pairs_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COMMA150;
    ProtoJSParser_option_pair_return option_pair149;
    #undef	RETURN_TYPE_option_pair149
    #define	RETURN_TYPE_option_pair149 ProtoJSParser_option_pair_return

    ProtoJSParser_option_pair_return option_pair151;
    #undef	RETURN_TYPE_option_pair151
    #define	RETURN_TYPE_option_pair151 ProtoJSParser_option_pair_return

    pANTLR3_BASE_TREE COMMA150_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    COMMA150       = NULL;
    option_pair149.tree = NULL;

    option_pair151.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    COMMA150_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:444:5: ( option_pair ( COMMA option_pair )* )
        // ProtoJS.g:445:5: option_pair ( COMMA option_pair )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_option_pair_in_option_pairs2388);
            option_pair149=option_pair(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoption_pairsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, option_pair149.tree);

            // ProtoJS.g:445:17: ( COMMA option_pair )*

            for (;;)
            {
                int alt27=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt27=1;
                	}
                    break;

                }

                switch (alt27) 
                {
            	case 1:
            	    // ProtoJS.g:445:18: COMMA option_pair
            	    {
            	        COMMA150 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_option_pairs2391); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoption_pairsEx;
            	        }

            	        COMMA150_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA150));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA150_tree);

            	        FOLLOWPUSH(FOLLOW_option_pair_in_option_pairs2393);
            	        option_pair151=option_pair(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoption_pairsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, option_pair151.tree);

            	    }
            	    break;

            	default:
            	    goto loop27;	/* break out of the loop */
            	    break;
                }
            }
            loop27: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoption_pairsEx; /* Prevent compiler warnings */
    ruleoption_pairsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end option_pairs */

/** 
 * $ANTLR start option_pair
 * ProtoJS.g:448:1: option_pair : ( ( DEFAULT EQUALS default_literal_value -> DEFAULT[\"default_value\"] COLON[\":\"] STRING_LITERAL[$default_literal_value.text->setS($default_literal_value.text,$field::defaultValue)] ) | ( IDENTIFIER EQUALS option_literal_value -> {strcmp((char*)$IDENTIFIER.text->chars,\"packed\")==0&&$NameSpace::isPBJ}? IDENTIFIER[\"_packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] -> IDENTIFIER COLON[\":\"] STRING_LITERAL[$option_pair.text->setS($option_pair.text,$option_pair::literalValue)] ) );
 */
static ProtoJSParser_option_pair_return
option_pair(pProtoJSParser ctx)
{   
    ProtoJSParser_option_pair_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DEFAULT152;
    pANTLR3_COMMON_TOKEN    EQUALS153;
    pANTLR3_COMMON_TOKEN    IDENTIFIER155;
    pANTLR3_COMMON_TOKEN    EQUALS156;
    ProtoJSParser_default_literal_value_return default_literal_value154;
    #undef	RETURN_TYPE_default_literal_value154
    #define	RETURN_TYPE_default_literal_value154 ProtoJSParser_default_literal_value_return

    ProtoJSParser_option_literal_value_return option_literal_value157;
    #undef	RETURN_TYPE_option_literal_value157
    #define	RETURN_TYPE_option_literal_value157 ProtoJSParser_option_literal_value_return

    pANTLR3_BASE_TREE DEFAULT152_tree;
    pANTLR3_BASE_TREE EQUALS153_tree;
    pANTLR3_BASE_TREE IDENTIFIER155_tree;
    pANTLR3_BASE_TREE EQUALS156_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_EQUALS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_IDENTIFIER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DEFAULT;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_default_literal_value;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_option_literal_value;
    /* Initialize rule variables
     */

    ctx->pProtoJSParser_option_pairTop = pProtoJSParser_option_pairPush(ctx);
    root_0 = NULL;

    DEFAULT152       = NULL;
    EQUALS153       = NULL;
    IDENTIFIER155       = NULL;
    EQUALS156       = NULL;
    default_literal_value154.tree = NULL;

    option_literal_value157.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DEFAULT152_tree   = NULL;
    EQUALS153_tree   = NULL;
    IDENTIFIER155_tree   = NULL;
    EQUALS156_tree   = NULL;

    stream_EQUALS   = NULL;
    #define CREATE_stream_EQUALS  if (stream_EQUALS == NULL) {stream_EQUALS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token EQUALS"); } 
    stream_IDENTIFIER   = NULL;
    #define CREATE_stream_IDENTIFIER  if (stream_IDENTIFIER == NULL) {stream_IDENTIFIER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token IDENTIFIER"); } 
    stream_DEFAULT   = NULL;
    #define CREATE_stream_DEFAULT  if (stream_DEFAULT == NULL) {stream_DEFAULT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DEFAULT"); } 
    stream_default_literal_value   = NULL;
    #define CREATE_stream_default_literal_value  if (stream_default_literal_value == NULL) {stream_default_literal_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule default_literal_value"); }
    stream_option_literal_value   = NULL;
    #define CREATE_stream_option_literal_value  if (stream_option_literal_value == NULL) {stream_option_literal_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule option_literal_value"); }

    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:450:5: ( ( DEFAULT EQUALS default_literal_value -> DEFAULT[\"default_value\"] COLON[\":\"] STRING_LITERAL[$default_literal_value.text->setS($default_literal_value.text,$field::defaultValue)] ) | ( IDENTIFIER EQUALS option_literal_value -> {strcmp((char*)$IDENTIFIER.text->chars,\"packed\")==0&&$NameSpace::isPBJ}? IDENTIFIER[\"_packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] -> IDENTIFIER COLON[\":\"] STRING_LITERAL[$option_pair.text->setS($option_pair.text,$option_pair::literalValue)] ) )
            
            ANTLR3_UINT32 alt28;

            alt28=2;

            switch ( LA(1) ) 
            {
            case DEFAULT:
            	{
            		alt28=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt28=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleoption_pairEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // ProtoJS.g:451:5: ( DEFAULT EQUALS default_literal_value -> DEFAULT[\"default_value\"] COLON[\":\"] STRING_LITERAL[$default_literal_value.text->setS($default_literal_value.text,$field::defaultValue)] )
        	    {
        	        // ProtoJS.g:451:5: ( DEFAULT EQUALS default_literal_value -> DEFAULT[\"default_value\"] COLON[\":\"] STRING_LITERAL[$default_literal_value.text->setS($default_literal_value.text,$field::defaultValue)] )
        	        // ProtoJS.g:451:6: DEFAULT EQUALS default_literal_value
        	        {
        	            DEFAULT152 = (pANTLR3_COMMON_TOKEN) MATCHT(DEFAULT, &FOLLOW_DEFAULT_in_option_pair2427); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }
        	             
        	            CREATE_stream_DEFAULT; stream_DEFAULT->add(stream_DEFAULT, DEFAULT152, NULL);

        	            EQUALS153 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_option_pair2429); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }
        	             
        	            CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS153, NULL);

        	            FOLLOWPUSH(FOLLOW_default_literal_value_in_option_pair2431);
        	            default_literal_value154=default_literal_value(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }

        	            CREATE_stream_default_literal_value; stream_default_literal_value->add(stream_default_literal_value, default_literal_value154.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : DEFAULT
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 451:43: -> DEFAULT[\"default_value\"] COLON[\":\"] STRING_LITERAL[$default_literal_value.text->setS($default_literal_value.text,$field::defaultValue)]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, DEFAULT, TOKTEXT("default_value"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DEFAULT, (pANTLR3_UINT8)"default_value")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, STRING_LITERAL, TOKTEXT((STRSTREAM->toStringTT(STRSTREAM, default_literal_value154.start, default_literal_value154.stop))->setS((STRSTREAM->toStringTT(STRSTREAM, default_literal_value154.start, default_literal_value154.stop)),	(SCOPE_TOP(field))->defaultValue)))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STRING_LITERAL, (pANTLR3_UINT8)(STRSTREAM->toStringTT(STRSTREAM, default_literal_value154.start, default_literal_value154.stop))->setS((STRSTREAM->toStringTT(STRSTREAM, default_literal_value154.start, default_literal_value154.stop)),	(SCOPE_TOP(field))->defaultValue))
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }


        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:453:5: ( IDENTIFIER EQUALS option_literal_value -> {strcmp((char*)$IDENTIFIER.text->chars,\"packed\")==0&&$NameSpace::isPBJ}? IDENTIFIER[\"_packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] -> IDENTIFIER COLON[\":\"] STRING_LITERAL[$option_pair.text->setS($option_pair.text,$option_pair::literalValue)] )
        	    {
        	        // ProtoJS.g:453:5: ( IDENTIFIER EQUALS option_literal_value -> {strcmp((char*)$IDENTIFIER.text->chars,\"packed\")==0&&$NameSpace::isPBJ}? IDENTIFIER[\"_packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"] -> IDENTIFIER COLON[\":\"] STRING_LITERAL[$option_pair.text->setS($option_pair.text,$option_pair::literalValue)] )
        	        // ProtoJS.g:453:6: IDENTIFIER EQUALS option_literal_value
        	        {
        	            IDENTIFIER155 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_option_pair2456); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }
        	             
        	            CREATE_stream_IDENTIFIER; stream_IDENTIFIER->add(stream_IDENTIFIER, IDENTIFIER155, NULL);

        	            EQUALS156 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUALS, &FOLLOW_EQUALS_in_option_pair2458); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }
        	             
        	            CREATE_stream_EQUALS; stream_EQUALS->add(stream_EQUALS, EQUALS156, NULL);

        	            FOLLOWPUSH(FOLLOW_option_literal_value_in_option_pair2460);
        	            option_literal_value157=option_literal_value(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoption_pairEx;
        	            }

        	            CREATE_stream_option_literal_value; stream_option_literal_value->add(stream_option_literal_value, option_literal_value157.tree, NULL);

        	             
        	            /* AST REWRITE
        	             * elements          : IDENTIFIER, IDENTIFIER
        	             * token labels      : 
        	             * rule labels       : retval
        	             * token list labels : 
        	             * rule list labels  : 
        	             */
        	            {
        	            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	            	retval.tree    = root_0;
        	            	// 454:8: -> {strcmp((char*)$IDENTIFIER.text->chars,\"packed\")==0&&$NameSpace::isPBJ}? IDENTIFIER[\"_packed\"] COLON[\":\"] BOOL_LITERAL[\"true\"]
        	            	if (strcmp((char*)(IDENTIFIER155->getText(IDENTIFIER155))->chars,"packed")==0&&	(SCOPE_TOP(NameSpace))->isPBJ) 
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, IDENTIFIER, TOKTEXT("_packed"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IDENTIFIER, (pANTLR3_UINT8)"_packed")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, BOOL_LITERAL, TOKTEXT("true"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BOOL_LITERAL, (pANTLR3_UINT8)"true")
        	            	    #endif
        	            	    );

        	            	}
        	            	else // 456:8: -> IDENTIFIER COLON[\":\"] STRING_LITERAL[$option_pair.text->setS($option_pair.text,$option_pair::literalValue)]
        	            	{
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, stream_IDENTIFIER == NULL ? NULL : stream_IDENTIFIER->nextNode(stream_IDENTIFIER));
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, COLON, TOKTEXT(":"))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COLON, (pANTLR3_UINT8)":")
        	            	    #endif
        	            	    );
        	            	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	            	    #if 1 == 2
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeTokenText(ADAPTOR, STRING_LITERAL, TOKTEXT(STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->setS(STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1)),	(SCOPE_TOP(option_pair))->literalValue)))
        	            	    #else
        	            	    	(pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STRING_LITERAL, (pANTLR3_UINT8)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->setS(STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1)),	(SCOPE_TOP(option_pair))->literalValue))
        	            	    #endif
        	            	    );

        	            	}

        	            	retval.tree = root_0; // set result root
        	            	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	            }
        	        }

        	        {

        	                 if (strcmp((char*)(IDENTIFIER155->getText(IDENTIFIER155))->chars,"packed")==0&&	(SCOPE_TOP(NameSpace))->isPBJ) {
        	                     fprintf(stderr,"error: line %d: packed not allowed in pbj, forcing true, overriding _packed in %s : %s\n",(IDENTIFIER155->getLine(IDENTIFIER155)),	(SCOPE_TOP(Symbols))->message->chars, 	(SCOPE_TOP(field))->fieldName->chars);
        	                 }
        	              
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleoption_pairEx; /* Prevent compiler warnings */
    ruleoption_pairEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_EQUALS != NULL) stream_EQUALS->free(stream_EQUALS);
        if (stream_IDENTIFIER != NULL) stream_IDENTIFIER->free(stream_IDENTIFIER);
        if (stream_DEFAULT != NULL) stream_DEFAULT->free(stream_DEFAULT);
        if (stream_default_literal_value != NULL) stream_default_literal_value->free(stream_default_literal_value);
        if (stream_option_literal_value != NULL) stream_option_literal_value->free(stream_option_literal_value);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }

    pProtoJSParser_option_pairPop(ctx);

    return retval;
}
/* $ANTLR end option_pair */

/** 
 * $ANTLR start option_literal_value
 * ProtoJS.g:464:1: option_literal_value : literal_value ;
 */
static ProtoJSParser_option_literal_value_return
option_literal_value(pProtoJSParser ctx)
{   
    ProtoJSParser_option_literal_value_return retval;

    pANTLR3_BASE_TREE root_0;

    ProtoJSParser_literal_value_return literal_value158;
    #undef	RETURN_TYPE_literal_value158
    #define	RETURN_TYPE_literal_value158 ProtoJSParser_literal_value_return


    /* Initialize rule variables
     */


    root_0 = NULL;

    literal_value158.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;



    retval.tree  = NULL;
    {
        // ProtoJS.g:464:22: ( literal_value )
        // ProtoJS.g:464:24: literal_value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_literal_value_in_option_literal_value2526);
            literal_value158=literal_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoption_literal_valueEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, literal_value158.tree);
            {

                        	(SCOPE_TOP(option_pair))->literalValue=defaultValuePreprocess(ctx, NULL, (STRSTREAM->toStringTT(STRSTREAM, literal_value158.start, literal_value158.stop)));
                   
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleoption_literal_valueEx; /* Prevent compiler warnings */
    ruleoption_literal_valueEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end option_literal_value */

/** 
 * $ANTLR start default_literal_value
 * ProtoJS.g:469:1: default_literal_value : ( literal_value | IDENTIFIER );
 */
static ProtoJSParser_default_literal_value_return
default_literal_value(pProtoJSParser ctx)
{   
    ProtoJSParser_default_literal_value_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IDENTIFIER160;
    ProtoJSParser_literal_value_return literal_value159;
    #undef	RETURN_TYPE_literal_value159
    #define	RETURN_TYPE_literal_value159 ProtoJSParser_literal_value_return

    pANTLR3_BASE_TREE IDENTIFIER160_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    IDENTIFIER160       = NULL;
    literal_value159.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    IDENTIFIER160_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:469:23: ( literal_value | IDENTIFIER )
            
            ANTLR3_UINT32 alt29;

            alt29=2;

            switch ( LA(1) ) 
            {
            case STRING_LITERAL:
            case HEX_LITERAL:
            case DECIMAL_LITERAL:
            case OCTAL_LITERAL:
            case FLOATING_POINT_LITERAL:
            case BOOL_LITERAL:
            	{
            		alt29=1;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt29=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruledefault_literal_valueEx;
            }

            switch (alt29) 
            {
        	case 1:
        	    // ProtoJS.g:469:25: literal_value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_literal_value_in_default_literal_value2540);
        	        literal_value159=literal_value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_literal_valueEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, literal_value159.tree);
        	        {

        	                    	(SCOPE_TOP(field))->defaultValue=defaultValuePreprocess(ctx, 	(SCOPE_TOP(field))->fieldType, (STRSTREAM->toStringTT(STRSTREAM, literal_value159.start, literal_value159.stop)));
        	              
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:474:3: IDENTIFIER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        IDENTIFIER160 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_default_literal_value2554); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledefault_literal_valueEx;
        	        }

        	        IDENTIFIER160_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IDENTIFIER160));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IDENTIFIER160_tree);

        	        {

        	                    	(SCOPE_TOP(field))->defaultValue=defaultValueIdentifierPreprocess(ctx, 	(SCOPE_TOP(field))->fieldType, (IDENTIFIER160->getText(IDENTIFIER160)));
        	              
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledefault_literal_valueEx; /* Prevent compiler warnings */
    ruledefault_literal_valueEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end default_literal_value */

/** 
 * $ANTLR start floating_point_type
 * ProtoJS.g:480:1: floating_point_type : FLOAT ;
 */
static ProtoJSParser_floating_point_type_return
floating_point_type(pProtoJSParser ctx)
{   
    ProtoJSParser_floating_point_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    FLOAT161;

    pANTLR3_BASE_TREE FLOAT161_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    FLOAT161       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    FLOAT161_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:480:21: ( FLOAT )
        // ProtoJS.g:480:23: FLOAT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FLOAT161 = (pANTLR3_COMMON_TOKEN) MATCHT(FLOAT, &FOLLOW_FLOAT_in_floating_point_type2569); 
            if  (HASEXCEPTION())
            {
                goto rulefloating_point_typeEx;
            }

            FLOAT161_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FLOAT161));
            ADAPTOR->addChild(ADAPTOR, root_0, FLOAT161_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefloating_point_typeEx; /* Prevent compiler warnings */
    rulefloating_point_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end floating_point_type */

/** 
 * $ANTLR start double_floating_point_type
 * ProtoJS.g:481:1: double_floating_point_type : DOUBLE ;
 */
static ProtoJSParser_double_floating_point_type_return
double_floating_point_type(pProtoJSParser ctx)
{   
    ProtoJSParser_double_floating_point_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOUBLE162;

    pANTLR3_BASE_TREE DOUBLE162_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    DOUBLE162       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    DOUBLE162_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:481:27: ( DOUBLE )
        // ProtoJS.g:481:29: DOUBLE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            DOUBLE162 = (pANTLR3_COMMON_TOKEN) MATCHT(DOUBLE, &FOLLOW_DOUBLE_in_double_floating_point_type2575); 
            if  (HASEXCEPTION())
            {
                goto ruledouble_floating_point_typeEx;
            }

            DOUBLE162_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOUBLE162));
            ADAPTOR->addChild(ADAPTOR, root_0, DOUBLE162_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledouble_floating_point_typeEx; /* Prevent compiler warnings */
    ruledouble_floating_point_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end double_floating_point_type */

/** 
 * $ANTLR start numeric_type
 * ProtoJS.g:482:1: numeric_type : ( UINT32 | INT32 | SINT32 | FIXED32 | SFIXED32 | UINT64 | INT64 | SINT64 | FIXED64 | SFIXED64 | BOOL );
 */
static ProtoJSParser_numeric_type_return
numeric_type(pProtoJSParser ctx)
{   
    ProtoJSParser_numeric_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set163;

    pANTLR3_BASE_TREE set163_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set163       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set163_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:482:13: ( UINT32 | INT32 | SINT32 | FIXED32 | SFIXED32 | UINT64 | INT64 | SINT64 | FIXED64 | SFIXED64 | BOOL )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set163=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= UINT32) && (LA(1) <= BOOL)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set163)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_numeric_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_numeric_type0);    goto rulenumeric_typeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenumeric_typeEx; /* Prevent compiler warnings */
    rulenumeric_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end numeric_type */

/** 
 * $ANTLR start array_type
 * ProtoJS.g:494:1: array_type : ( STRING | BYTES );
 */
static ProtoJSParser_array_type_return
array_type(pProtoJSParser ctx)
{   
    ProtoJSParser_array_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set164;

    pANTLR3_BASE_TREE set164_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set164       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set164_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:494:11: ( STRING | BYTES )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set164=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= STRING) && (LA(1) <= BYTES)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set164)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_array_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_array_type0);    goto rulearray_typeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulearray_typeEx; /* Prevent compiler warnings */
    rulearray_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end array_type */

/** 
 * $ANTLR start multiplicitive_advanced_type
 * ProtoJS.g:498:1: multiplicitive_advanced_type : ( NORMAL | VECTOR2F | VECTOR2D | VECTOR3F | VECTOR3D | VECTOR4F | VECTOR4D | UNITQUATERNION | QUATERNION | BOUNDINGSPHERE3F | BOUNDINGSPHERE3D | BOUNDINGBOX3F3F | BOUNDINGBOX3D3F );
 */
static ProtoJSParser_multiplicitive_advanced_type_return
multiplicitive_advanced_type(pProtoJSParser ctx)
{   
    ProtoJSParser_multiplicitive_advanced_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set165;

    pANTLR3_BASE_TREE set165_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set165       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set165_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:499:5: ( NORMAL | VECTOR2F | VECTOR2D | VECTOR3F | VECTOR3D | VECTOR4F | VECTOR4D | UNITQUATERNION | QUATERNION | BOUNDINGSPHERE3F | BOUNDINGSPHERE3D | BOUNDINGBOX3F3F | BOUNDINGBOX3D3F )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set165=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= NORMAL) && (LA(1) <= BOUNDINGBOX3D3F)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set165)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_multiplicitive_advanced_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_multiplicitive_advanced_type0);    goto rulemultiplicitive_advanced_typeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemultiplicitive_advanced_typeEx; /* Prevent compiler warnings */
    rulemultiplicitive_advanced_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end multiplicitive_advanced_type */

/** 
 * $ANTLR start advanced_numeric_type
 * ProtoJS.g:514:1: advanced_numeric_type : ( UINT8 | INT8 | SINT8 | FIXED8 | SFIXED8 | INT16 | SINT16 | FIXED16 | SFIXED16 | UINT16 | ANGLE | TIME | DURATION );
 */
static ProtoJSParser_advanced_numeric_type_return
advanced_numeric_type(pProtoJSParser ctx)
{   
    ProtoJSParser_advanced_numeric_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set166;

    pANTLR3_BASE_TREE set166_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set166       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set166_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:514:22: ( UINT8 | INT8 | SINT8 | FIXED8 | SFIXED8 | INT16 | SINT16 | FIXED16 | SFIXED16 | UINT16 | ANGLE | TIME | DURATION )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set166=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= UINT8) && (LA(1) <= DURATION)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set166)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_advanced_numeric_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_advanced_numeric_type0);    goto ruleadvanced_numeric_typeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleadvanced_numeric_typeEx; /* Prevent compiler warnings */
    ruleadvanced_numeric_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end advanced_numeric_type */

/** 
 * $ANTLR start advanced_array_type
 * ProtoJS.g:529:1: advanced_array_type : ( UUID | SHA256 );
 */
static ProtoJSParser_advanced_array_type_return
advanced_array_type(pProtoJSParser ctx)
{   
    ProtoJSParser_advanced_array_type_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set167;

    pANTLR3_BASE_TREE set167_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set167       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set167_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:529:20: ( UUID | SHA256 )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set167=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= UUID) && (LA(1) <= SHA256)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set167)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_advanced_array_type0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_advanced_array_type0);    goto ruleadvanced_array_typeEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleadvanced_array_typeEx; /* Prevent compiler warnings */
    ruleadvanced_array_typeEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end advanced_array_type */

/** 
 * $ANTLR start literal_value
 * ProtoJS.g:533:1: literal_value : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | BOOL_LITERAL | STRING_LITERAL );
 */
static ProtoJSParser_literal_value_return
literal_value(pProtoJSParser ctx)
{   
    ProtoJSParser_literal_value_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set168;

    pANTLR3_BASE_TREE set168_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set168       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set168_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:534:2: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | BOOL_LITERAL | STRING_LITERAL )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set168=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( LA(1) == STRING_LITERAL || ((LA(1) >= HEX_LITERAL) && (LA(1) <= BOOL_LITERAL)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set168)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_literal_value0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_literal_value0);    goto ruleliteral_valueEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleliteral_valueEx; /* Prevent compiler warnings */
    ruleliteral_valueEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end literal_value */

/** 
 * $ANTLR start flags
 * ProtoJS.g:558:1: flags : ( FLAGS8 | FLAGS16 | FLAGS32 | FLAGS64 );
 */
static ProtoJSParser_flags_return
flags(pProtoJSParser ctx)
{   
    ProtoJSParser_flags_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    FLAGS8169;
    pANTLR3_COMMON_TOKEN    FLAGS16170;
    pANTLR3_COMMON_TOKEN    FLAGS32171;
    pANTLR3_COMMON_TOKEN    FLAGS64172;

    pANTLR3_BASE_TREE FLAGS8169_tree;
    pANTLR3_BASE_TREE FLAGS16170_tree;
    pANTLR3_BASE_TREE FLAGS32171_tree;
    pANTLR3_BASE_TREE FLAGS64172_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    FLAGS8169       = NULL;
    FLAGS16170       = NULL;
    FLAGS32171       = NULL;
    FLAGS64172       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    FLAGS8169_tree   = NULL;
    FLAGS16170_tree   = NULL;
    FLAGS32171_tree   = NULL;
    FLAGS64172_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  ProtoJS.g:558:7: ( FLAGS8 | FLAGS16 | FLAGS32 | FLAGS64 )
            
            ANTLR3_UINT32 alt30;

            alt30=4;

            switch ( LA(1) ) 
            {
            case FLAGS8:
            	{
            		alt30=1;
            	}
                break;
            case FLAGS16:
            	{
            		alt30=2;
            	}
                break;
            case FLAGS32:
            	{
            		alt30=3;
            	}
                break;
            case FLAGS64:
            	{
            		alt30=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;


                goto ruleflagsEx;
            }

            switch (alt30) 
            {
        	case 1:
        	    // ProtoJS.g:559:6: FLAGS8
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FLAGS8169 = (pANTLR3_COMMON_TOKEN) MATCHT(FLAGS8, &FOLLOW_FLAGS8_in_flags3097); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleflagsEx;
        	        }

        	        FLAGS8169_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FLAGS8169));
        	        ADAPTOR->addChild(ADAPTOR, root_0, FLAGS8169_tree);

        	        {

        	                    	(SCOPE_TOP(flags_def))->flagBits=8;
        	                 
        	        }

        	    }
        	    break;
        	case 2:
        	    // ProtoJS.g:564:6: FLAGS16
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FLAGS16170 = (pANTLR3_COMMON_TOKEN) MATCHT(FLAGS16, &FOLLOW_FLAGS16_in_flags3118); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleflagsEx;
        	        }

        	        FLAGS16170_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FLAGS16170));
        	        ADAPTOR->addChild(ADAPTOR, root_0, FLAGS16170_tree);

        	        {

        	                    	(SCOPE_TOP(flags_def))->flagBits=16;
        	                 
        	        }

        	    }
        	    break;
        	case 3:
        	    // ProtoJS.g:569:6: FLAGS32
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FLAGS32171 = (pANTLR3_COMMON_TOKEN) MATCHT(FLAGS32, &FOLLOW_FLAGS32_in_flags3139); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleflagsEx;
        	        }

        	        FLAGS32171_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FLAGS32171));
        	        ADAPTOR->addChild(ADAPTOR, root_0, FLAGS32171_tree);

        	        {

        	                    	(SCOPE_TOP(flags_def))->flagBits=32;
        	                 
        	        }

        	    }
        	    break;
        	case 4:
        	    // ProtoJS.g:574:6: FLAGS64
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FLAGS64172 = (pANTLR3_COMMON_TOKEN) MATCHT(FLAGS64, &FOLLOW_FLAGS64_in_flags3160); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleflagsEx;
        	        }

        	        FLAGS64172_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FLAGS64172));
        	        ADAPTOR->addChild(ADAPTOR, root_0, FLAGS64172_tree);

        	        {

        	                    	(SCOPE_TOP(flags_def))->flagBits=64;
        	                 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleflagsEx; /* Prevent compiler warnings */
    ruleflagsEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end flags */

/** 
 * $ANTLR start integer
 * ProtoJS.g:653:1: integer : ( DECIMAL_LITERAL | HEX_LITERAL | OCTAL_LITERAL );
 */
static ProtoJSParser_integer_return
integer(pProtoJSParser ctx)
{   
    ProtoJSParser_integer_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set173;

    pANTLR3_BASE_TREE set173_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    set173       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    set173_tree   = NULL;


    retval.tree  = NULL;
    {
        // ProtoJS.g:654:5: ( DECIMAL_LITERAL | HEX_LITERAL | OCTAL_LITERAL )
        // ProtoJS.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            set173=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( ((LA(1) >= HEX_LITERAL) && (LA(1) <= OCTAL_LITERAL)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set173)));
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_integer0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_integer0);    goto ruleintegerEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end integer */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
